Architectural Specification and Implementation Report: High-Performance Deterministic Globbing Engine for AriaBuild
1. Introduction: The Necessity of a Specialized File Discovery Subsystem
The modernization of software build infrastructure demands a paradigm shift from loose, imperative scripting to strict, declarative configuration. The AriaBuild system (internally aria_make) is designed to replace legacy tools like GNU Make within the Aria ecosystem, aiming for hermeticity, reproducibility, and high-throughput parallelism. Central to any build system is the ability to discover source code files, header dependencies, and asset resources scattered across a filesystem. This process, known as "globbing," requires a mechanism that is both semantically precise and computationally efficient.
While the C++ standard library provides robust facilities for filesystem interaction via std::filesystem and pattern matching via std::regex, a comprehensive architectural audit reveals that these general-purpose tools are insufficient for the specialized constraints of a high-performance build system. std::regex, while powerful, introduces significant compilation overhead and semantic mismatches when applied to filesystem paths—specifically regarding the handling of directory separators and the behavior of the "dot" wildcard.1 Furthermore, the requirement for absolute cross-platform determinism between Unix-like environments and Windows necessitates a bespoke solution that abstracts away operating system idiosyncrasies, such as hidden file attributes and path separators.3
This report details the architectural design, theoretical framework, and complete C++17 implementation of the AriaBuild Globbing Engine. This standalone component is engineered to satisfy the critical priority requirement of efficient source file discovery. The solution leverages the "Shifting Wildcard" algorithm—a greedy backtracking strategy—to achieve near-linear time matching performance, eschewing the heavy memory footprint of Nondeterministic Finite Automata (NFA) used in regex engines. We present a modular architecture comprising a GlobPattern parser, a FastMatcher kernel, and a GlobEngine traversal unit, complete with platform-specific optimizations for hidden file detection and timestamp-based cache invalidation.
1.1 The Semantic Mismatch of Regular Expressions
A foundational decision in this architecture is the explicit rejection of std::regex as the underlying matching mechanism. While it is theoretically possible to transpile glob patterns into regular expressions (e.g., converting src/**/*.aria to ^src/.*\.aria$), this approach introduces subtle but critical semantic friction that degrades both performance and correctness.
The primary divergence lies in the definition of the wildcard. In POSIX globbing standards, the asterisk * matches any sequence of characters except the directory separator (/ on Unix, \ on Windows). This "separator-aware" behavior is fundamental to preventing accidental recursion into subdirectories when a flat match is intended. In contrast, the standard regex wildcard . typically matches any character. To replicate glob behavior, a regex must use complex negated character classes (e.g., [^/\\]*). This increases the complexity of the internal state machine and makes the pattern harder to debug.1
Moreover, benchmarks indicate that std::regex implementations in major standard libraries (libstdc++, libc++) often suffer from slow compilation times. For a build system that may need to resolve thousands of distinct include patterns during the configuration phase, the cumulative latency of compiling thousands of regex objects is unacceptable.5 The proposed FastMatcher avoids this compilation step entirely, operating directly on the pattern string with constant space overhead.
1.2 System Requirements and Scope
The design of the AriaBuild Globbing Engine is driven by the following strict requirements:
* Performance: The matching kernel must operate in $O(N)$ time for typical patterns, avoiding the exponential backtracking scenarios common in poorly optimized regexes.
* Correctness: The engine must support the recursive globstar **, which matches zero or more directory levels, and strictly enforce POSIX character class rules (e.g., [a-z], [!0-9]).6
* Determinism: The order of returned files must be lexicographically sorted, ensuring that build artifacts are bit-for-bit identical regardless of the filesystem's underlying iteration order (which varies between ext4, NTFS, and APFS).
* Cross-Platform Consistency: The engine must normalize Windows backslashes to Unix forward slashes and provide a unified mechanism for detecting hidden files, abstracting the difference between the Unix "dot-file" convention and the Windows FILE_ATTRIBUTE_HIDDEN bit.8
* Caching: To support incremental builds, the engine must cache results and invalidate them intelligently based on directory modification timestamps.
________________
2. Theoretical Framework
2.1 Automata Theory vs. Greedy Backtracking
Pattern matching algorithms generally fall into two categories: automata-based approaches and backtracking approaches. Regular expression engines typically compile patterns into a Nondeterministic Finite Automaton (NFA) or a Deterministic Finite Automaton (DFA). While DFAs offer guaranteed linear-time execution, the compilation phase can be expensive ($O(2^M)$ states in the worst case), and the memory consumption can be significant.
The "Shifting Wildcard" algorithm employed in the FastMatcher is a greedy backtracking algorithm. It does not construct a state machine. Instead, it maintains two pointers: one for the text (filename) and one for the pattern. When a wildcard * is encountered, the algorithm greedily assumes it matches zero characters initially. If a subsequent mismatch occurs, the algorithm "shifts" the wildcard match to consume one more character of the text and retries.
This approach is particularly well-suited for filenames because "pathological" backtracking cases (e.g., matching *a*b against a string of aaaa...) are extremely rare in valid filesystem paths. Consequently, the algorithm runs in effective linear time without the overhead of memory allocation for state tables.10
2.2 Formal Grammar of Aria Globs
To ensure unambiguous parsing, we define the supported glob grammar as a superset of POSIX 1003.2 glob protocols, extended with the ** operator popularized by zsh and rsync.
Token
	Name
	Semantics
	Complexity Profile
	*
	Wildcard
	Matches $0 \dots N$ characters in the current segment. Stops at /.
	Linear (with backtracking)
	?
	Unit Wildcard
	Matches exactly 1 character. Stops at /.
	Linear
	**
	Globstar
	Matches $0 \dots N$ directory segments. Crosses / boundaries.
	Exponential $O(B^D)$ worst-case
	[...]
	Character Class
	Matches 1 character from the set. Supports ranges (-) and negation (!).
	Constant $O(1)$ relative to set size
	\
	Escape
	Treats the next character as a literal (e.g., \*).
	Linear parsing overhead
	2.3 Character Class Algebra
A critical gap identified in the initial research was the specific logic for POSIX character classes.3 The syntax [...] is not merely a set of characters; it is a mini-language with specific edge cases:
1. Ranges: [a-z] denotes all ASCII characters between 'a' and 'z' inclusive.
2. Negation: If the first character after [ is ! or ^, the match is inverted.
3. Literal ]: To match a literal closing bracket, it must be the first character in the class (e.g., abc]).
4. Literal -: To match a literal dash, it must be the first or last character (e.g., [-abc] or [abc-]).6
The FastMatcher implements a dedicated state machine to parse these rules without recursion, ensuring safety against stack overflow attacks via malformed patterns.
________________
3. System Architecture
The Globbing Engine is architected as a pipeline of three distinct stages: Pattern Analysis, Algorithmic Matching, and Filesystem Traversal. This separation of concerns facilitates unit testing and allows the matching kernel to be used independently of the filesystem (e.g., for filtering strings in memory).
3.1 Component Diagram
1. GlobPattern (Parser):
   * Input: Raw string (e.g., src\**\*.cpp).
   * Process: Normalizes separators to /. Tokenizes into a vector of segments (src, **, *.cpp). Calculates the "Anchor Point" (the deepest static directory path, e.g., src).
   * Output: Normalized Segment vector and anchor path.
2. FastMatcher (Kernel):
   * Input: Candidate string (filename) and Pattern segment.
   * Process: Executes the Shifting Wildcard algorithm. Handles character classes and simple wildcards.
   * Output: Boolean match result.
3. GlobEngine (Orchestrator):
   * Input: GlobPattern object.
   * Process: Checks cache. If miss, initiates traversal at the Anchor Point. Iterates directories, filters hidden files using OS-specific APIs, recurses on **, and accumulates matches.
   * Output: Sorted std::vector<std::filesystem::path>.
________________
4. Implementation Detail: The Parser (GlobPattern)
The GlobPattern class is responsible for sanitizing user input. In a cross-platform build system, path separators are a primary source of non-determinism. Windows allows both \ and /, while Unix strictly uses /. To ensure that a pattern written on one OS behaves identically on another, we normalize all separators to the internal representation of /.
4.1 Anchor Point Optimization
A naive globbing implementation might start scanning at the current working directory and filter paths as it goes. This is inefficient for patterns like src/core/net/**/*.cpp. The efficient approach is to identify the "Anchor Point"—the longest prefix of the pattern that contains no wildcards. For the example above, the anchor is src/core/net. The engine should jump directly to this directory before beginning iteration, pruning the traversal tree significantly.
4.2 Source Code: include/glob/glob_pattern.h


C++




#ifndef ARIA_GLOB_PATTERN_H
#define ARIA_GLOB_PATTERN_H

#include <string>
#include <vector>
#include <filesystem>
#include <algorithm>

namespace aria::glob {

enum class SegmentType {
   Literal,    // matches exactly "text"
   Wildcard,   // matches using FastMatcher (*,?, [...])
   Recursive   // matches directories recursively (**)
};

struct Segment {
   std::string text;
   SegmentType type;
};

/**
* @class GlobPattern
* @brief Parses and normalizes a glob pattern string into actionable segments.
* 
* Responsible for handling path separators (unifying to forward slash) and
* identifying the "Anchor Point" (the static prefix) to optimize traversal start.
*/
class GlobPattern {
public:
   explicit GlobPattern(const std::string& pattern);

   const std::vector<Segment>& segments() const { return m_segments; }
   bool is_absolute() const { return m_is_absolute; }
   
   // Returns the static path prefix where traversal should begin
   std::filesystem::path get_anchor() const;

private:
   std::vector<Segment> m_segments;
   bool m_is_absolute = false;

   void parse(std::string pattern);
   SegmentType classify_segment(const std::string& token) const;
};

} // namespace aria::glob

#endif // ARIA_GLOB_PATTERN_H

4.3 Source Code: src/glob/glob_pattern.cpp


C++




#include "glob/glob_pattern.h"
#include <sstream>

namespace aria::glob {

GlobPattern::GlobPattern(const std::string& pattern) {
   parse(pattern);
}

void GlobPattern::parse(std::string pattern) {
   if (pattern.empty()) return;

   // 1. Normalize separators: Unified to forward slash '/'
   // This ensures patterns like "src\**\*.cpp" work on Linux.
   std::replace(pattern.begin(), pattern.end(), '\\', '/');

   // 2. Check for absolute path
   // Unix: starts with '/'
   if (pattern.length() >= 1 && pattern == '/') {
       m_is_absolute = true;
   } 
   // Windows: Drive letter check (e.g. C:/)
   else if (pattern.length() >= 3 && pattern == ':' && pattern == '/') {
       m_is_absolute = true;
   }

   // 3. Tokenize into segments
   std::string token;
   std::stringstream ss(pattern);
   
   // std::getline with delimiter splits by '/'
   while (std::getline(ss, token, '/')) {
       if (token.empty()) continue; // Skip repeated separators "//"
       
       Segment seg;
       seg.text = token;
       seg.type = classify_segment(token);
       m_segments.push_back(seg);
   }
}

SegmentType GlobPattern::classify_segment(const std::string& token) const {
   if (token == "**") return SegmentType::Recursive;
   
   // Scan for wildcard characters, respecting escapes
   bool escaped = false;
   for (char c : token) {
       if (escaped) {
           escaped = false;
           continue;
       }
       if (c == '\\') {
           escaped = true;
           continue;
       }
       // Check for *,?, or

### 5.1 Optimization via `std::string_view`
Strings in C++ (`std::string`) manage their own memory, often involving heap allocation for strings larger than the Small String Optimization (SSO) buffer. In a globbing engine, we repeatedly slice pattern strings and filenames during recursion. Using `std::string` copies would generate immense allocator pressure.

By adopting `std::string_view` (C++17), we pass lightweight pointers and lengths (16 bytes on 64-bit systems) instead of deep-copying string data. This ensures the matching logic is effectively zero-copy, limited only by CPU cache bandwidth.[13]

### 5.2 Source Code: `include/glob/fast_matcher.h`

```cpp
#ifndef ARIA_GLOB_FAST_MATCHER_H
#define ARIA_GLOB_FAST_MATCHER_H

#include <string_view>

namespace aria::glob {

class FastMatcher {
public:
   /**
    * Matches text against a glob pattern using the Shifting Wildcard algorithm.
    * 
    * @param text The filename to check (e.g., "main.cpp").
    * @param pattern The pattern segment (e.g., "*.cpp" or "test_?.aria").
    * @return true if the text matches the pattern.
    */
   static bool match(std::string_view text, std::string_view pattern);

private:
   /**
    * Parses and matches a POSIX character class [...]
    * 
    * @param c The character to check.
    * @param p_sub The pattern starting at ' == '?' |

| pattern[p_idx] == text[t_idx])) {
           t_idx++;
           p_idx++;
           continue;
       }

       // Case 2: Character Class [...]
       if (p_idx < pattern.length() && pattern[p_idx] == '[') {
           bool matched = false;
           size_t consumed = match_class(text[t_idx], pattern.substr(p_idx), matched);
           
           // If match_class returns >0, it was a valid class syntax.
           if (consumed > 0 && matched) {
               t_idx++;
               p_idx += consumed;
               continue;
           }
           // If valid class syntax but character didn't match, we fall through to mismatch logic.
           // If invalid syntax (consumed==0), we treat '[' as literal or fail.
           if (consumed == 0 && pattern[p_idx] == text[t_idx]) {
               // Treat as literal ' == '*') {
           last_star = p_idx;
           match_pos = t_idx;
           p_idx++; // Advance pattern, assume * matches 0 chars initially
           continue;
       }

       // Case 4: Mismatch - Attempt Backtracking
       // If we previously saw a '*', we can try to let it consume one more character.
       if (last_star!= std::string_view::npos) {
           p_idx = last_star + 1; // Reset pattern to char after *
           match_pos++;           // Consume one char from text for the *
           t_idx = match_pos;     // Reset text pointer
           continue;
       }

       return false; // Mismatch and no star to backtrack to
   }

   // Cleanup: The text is exhausted. 
   // The match is only successful if remaining pattern chars are all '*' 
   // (which can match the empty string suffix).
   while (p_idx < pattern.length() && pattern[p_idx] == '*') {
       p_idx++;
   }

   return p_idx == pattern.length();
}

size_t FastMatcher::match_class(char c, std::string_view p, bool& out_matched) {
   // p starts with '['
   if (p.length() < 2) return 0; // Malformed: "[", need at least "" or "[.]"

   size_t idx = 1; // Start after '['
   bool negate = false;
   
   // Check negation: [!...] or [^...]
   if (idx < p.length() && (p[idx] == '!' |

| p[idx] == '^')) {
       negate = true;
       idx++;
   }

   // POSIX special rule: ']' immediately after opening (or negation) is a literal ']'
   // e.g.,abc] or [!]]
   bool first_char = true;
   bool found_match = false;

   while (idx < p.length()) {
       // Check for end of class
       if (p[idx] == ']' &&!first_char) {
           // End of class found
           out_matched = (negate?!found_match : found_match);
           return idx + 1; // Return total length including brackets
       }

       // Check range a-z
       // Needs at least 3 chars: start - end
       if (idx + 2 < p.length() && p[idx + 1] == '-' && p[idx + 2]!= ']') {
           char start = p[idx];
           char end = p[idx + 2];
           
           // Basic ASCII range check
           if (c >= start && c <= end) {
               found_match = true;
           }
           idx += 3; // Consume "a-z"
       } 
       else {
           // Literal char match
           if (p[idx] == c) {
               found_match = true;
           }
           idx++;
       }
       first_char = false;
   }

   return 0; // Malformed (no closing bracket found)
}

} // namespace aria::glob

________________
6. Implementation Detail: The Traversal Engine (GlobEngine)
The GlobEngine interacts with the physical filesystem. Its implementation must handle the "messy" reality of OS storage: hidden files, recursion loops, and permission errors.
6.1 Platform-Independent Hidden File Detection
A key requirement is platform independence.
* Unix/Linux: Files starting with . are hidden. std::filesystem does not treat them specially, so we must manually check path.filename().string() == '.'.
* Windows: Hidden status is a file attribute (FILE_ATTRIBUTE_HIDDEN). std::filesystem does not expose this attribute directly in C++17. We must use the Win32 API GetFileAttributesW. This creates a divergence we must abstract.8
6.2 Timestamp-Based Caching
To speed up the "configure" phase in incremental builds, we cache glob results. The cache key is a combination of the pattern hash and the anchor directory's signature.
* Cache Invalidation: We store fs::last_write_time(anchor) alongside the results. On subsequent calls, we check if the anchor's timestamp has changed.
* Key Generation: We use a hash combine function to mix std::hash<string> (pattern) and std::filesystem::hash_value (path).
6.3 Source Code: include/glob/glob_engine.h


C++




#ifndef ARIA_GLOB_ENGINE_H
#define ARIA_GLOB_ENGINE_H

#include <vector>
#include <string>
#include <filesystem>
#include <unordered_map>
#include <mutex>
#include "glob_pattern.h"

namespace aria::glob {

/**
* @class GlobEngine
* @brief High-level orchestration of filesystem traversal and pattern expansion.
* 
* Features:
* - Segment-based recursive traversal (Anchor Point optimization).
* - Caching with timestamp invalidation.
* - Platform-specific hidden file handling (Unix dotfiles / Windows attributes).
* - Deterministic output sorting.
*/
class GlobEngine {
public:
   // Main API: Expands a pattern into a list of paths
   std::vector<std::filesystem::path> expand(const std::string& pattern_str);

   // Clears the internal cache (useful for 'clean' builds)
   void clear_cache();

private:
   struct CacheEntry {
       std::filesystem::file_time_type timestamp;
       std::vector<std::filesystem::path> results;
   };

   // Cache mapping: CombinedHash -> Entry
   std::unordered_map<size_t, CacheEntry> m_cache;
   std::mutex m_cache_mutex;

   // Internal recursive walker
   void walk(const std::filesystem::path& current_path, 
             const std::vector<Segment>& segments, 
             size_t seg_idx, 
             std::vector<std::filesystem::path>& results);

   // Platform-specific hidden check
   bool is_hidden(const std::filesystem::path& path);
   
   // Cache helper
   size_t generate_cache_key(const std::string& pattern, const std::filesystem::path& anchor);
};

} // namespace aria::glob

#endif // ARIA_GLOB_ENGINE_H

6.4 Source Code: src/glob/glob_engine.cpp


C++




#include "glob/glob_engine.h"
#include "glob/fast_matcher.h"
#include <iostream>
#include <algorithm> // for std::sort

// Platform includes for hidden files
#if defined(_WIN32)
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

namespace fs = std::filesystem;

namespace aria::glob {

std::vector<fs::path> GlobEngine::expand(const std::string& pattern_str) {
   GlobPattern pattern(pattern_str);
   fs::path anchor = pattern.get_anchor();

   // 1. Cache Lookup Logic
   // We assume the anchor's timestamp is a proxy for the validity of the subtree search.
   // Note: This is an approximation. Changes deep in the tree might not update the anchor's mtime 
   // on all filesystems, but it suffices for rapid incremental build checks.
   
   size_t key = generate_cache_key(pattern_str, anchor);
   std::error_code ec;
   auto anchor_time = fs::last_write_time(anchor, ec);
   
   // If anchor doesn't exist, return empty immediately
   if (ec) return {};

   {
       std::lock_guard<std::mutex> lock(m_cache_mutex);
       auto it = m_cache.find(key);
       if (it!= m_cache.end()) {
           if (it->second.timestamp == anchor_time) {
               // Cache Hit: Timestamp matches
               return it->second.results;
           }
           // Cache Miss: Timestamp changed, implicit invalidation happens by overwriting
       }
   }

   // 2. Traversal
   std::vector<fs::path> results;
   
   // Determine where in the segment list to start matching.
   // The anchor consumes 'N' literal segments.
   size_t start_seg_idx = 0;
   
   // Re-verify segment alignment. 
   // If pattern is "src/core/**/*.cpp" and anchor is "src/core", we start at segment 2 ("**").
   // We walk the segments to find the first non-literal.
   for(size_t i=0; i<pattern.segments().size(); ++i) {
       if(pattern.segments()[i].type!= SegmentType::Literal) {
           start_seg_idx = i;
           break;
       }
   }

   walk(anchor, pattern.segments(), start_seg_idx, results);

   // 3. Deterministic Sort
   // Filesystems do not guarantee iteration order. To ensure bit-for-bit reproducible builds,
   // we must sort the output paths lexicographically.
   std::sort(results.begin(), results.end());

   // 4. Update Cache
   {
       std::lock_guard<std::mutex> lock(m_cache_mutex);
       m_cache[key] = {anchor_time, results};
   }

   return results;
}

void GlobEngine::walk(const fs::path& current_path, 
                     const std::vector<Segment>& segments, 
                     size_t seg_idx, 
                     std::vector<fs::path>& results) {
   
   // Base Case: We have processed all pattern segments.
   // The current path matches the full pattern.
   if (seg_idx >= segments.size()) {
       results.push_back(current_path);
       return;
   }

   const auto& segment = segments[seg_idx];
   bool is_last_segment = (seg_idx == segments.size() - 1);
   std::error_code ec;

   // Check directory existence before iterating
   if (!fs::exists(current_path, ec) ||!fs::is_directory(current_path, ec)) {
       return;
   }

   // --- Handling Recursive Globstar "**" ---
   if (segment.type == SegmentType::Recursive) {
       // Semantic: "**" matches zero or more directories.
       
       // Branch 1: The "**" matches ZERO directories.
       // We attempt to match the NEXT segment against the current directory's contents.
       if (!is_last_segment) {
            walk(current_path, segments, seg_idx + 1, results);
       } else {
            // Trailing "**" (e.g., "src/**") matches everything recursively from here down.
            // We use recursive_directory_iterator for efficiency.
            for(auto it = fs::recursive_directory_iterator(current_path, fs::directory_options::skip_permission_denied, ec);
                it!= fs::recursive_directory_iterator(); ++it) {
                if (!is_hidden(it->path())) {
                    results.push_back(it->path());
                }
            }
            return; // Done with this branch
       }

       // Branch 2: The "**" matches ONE or MORE directories.
       // We iterate subdirectories, and for each one, we keep the "**" segment active (don't increment seg_idx).
       for (const auto& entry : fs::directory_iterator(current_path, fs::directory_options::skip_permission_denied, ec)) {
           if (is_hidden(entry.path())) continue;
           
           if (entry.is_directory()) {
               walk(entry.path(), segments, seg_idx, results);
           }
       }
   } 
   // --- Handling Standard Segments (Literal or Wildcard) ---
   else { 
       for (const auto& entry : fs::directory_iterator(current_path, fs::directory_options::skip_permission_denied, ec)) {
           if (is_hidden(entry.path())) continue;

           std::string filename = entry.path().filename().string();
           bool match = false;

           if (segment.type == SegmentType::Literal) {
               match = (filename == segment.text);
           } else {
               // Delegate to FastMatcher
               match = FastMatcher::match(filename, segment.text);
           }

           if (match) {
               if (is_last_segment) {
                   // Match found!
                   results.push_back(entry.path());
               } else if (entry.is_directory()) {
                   // Continue traversal
                   walk(entry.path(), segments, seg_idx + 1, results);
               }
           }
       }
   }
}

bool GlobEngine::is_hidden(const fs::path& path) {
   // 1. Unix-style dotfile check
   // This is applied on all platforms for consistency in the build system.
   // (e.g.,.git folders should be ignored on Windows too)
   if (path.filename().string().rfind(".", 0) == 0) {
       return true;
   }

#if defined(_WIN32)
   // 2. Windows specific attribute check
   // std::filesystem does not expose Hidden attribute.
   // We use Win32 API GetFileAttributesW.
   DWORD attributes = GetFileAttributesW(path.c_str());
   if (attributes!= INVALID_FILE_ATTRIBUTES && (attributes & FILE_ATTRIBUTE_HIDDEN)) {
       return true;
   }
#endif

   return false;
}

size_t GlobEngine::generate_cache_key(const std::string& pattern, const fs::path& anchor) {
   // Combine hashes of pattern string and anchor path
   size_t h1 = std::hash<std::string>{}(pattern);
   size_t h2 = std::filesystem::hash_value(anchor); // C++17 extension
   
   // Simple hash combine
   return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2)); 
}

} // namespace aria::glob

________________
7. Performance Benchmarking
To validate the "high-performance" requirement, we evaluate the FastMatcher against std::regex. The benchmark scenario simulates matching a pattern src/net/*.cpp against a dataset of 100,000 strings, a typical load for large monorepo builds.
7.1 Benchmark Methodology
We measure two distinct phases:
1. Compilation/Parsing: Time taken to construct the matcher object (Regex std::regex(pat) vs. Glob GlobPattern(pat)).
2. Matching: Time taken to execute regex_match vs FastMatcher::match.
7.2 Implementation: benchmarks/benchmark_glob.cpp


C++




#include <iostream>
#include <vector>
#include <string>
#include <regex>
#include <chrono>
#include "glob/fast_matcher.h"
#include "glob/glob_pattern.h"

using namespace std::chrono;

void run_benchmark() {
   std::cout << "Starting Benchmark: std::regex vs aria::FastMatcher\n";
   
   // Dataset: 100,000 filenames
   // 10% match the pattern "*.cpp"
   std::vector<std::string> dataset;
   dataset.reserve(100000);
   for (int i = 0; i < 90000; ++i) dataset.push_back("image_" + std::to_string(i) + ".png");
   for (int i = 0; i < 10000; ++i) dataset.push_back("source_" + std::to_string(i) + ".cpp");

   std::string pattern_str = "*.cpp";
   std::string regex_str = ".*\\.cpp"; // Regex equivalent

   // --- std::regex Benchmark ---
   auto start_regex = high_resolution_clock::now();
   {
       std::regex re(regex_str); // Compilation cost included
       int matches = 0;
       for (const auto& s : dataset) {
           if (std::regex_match(s, re)) matches++;
       }
       volatile int keep = matches; // Prevent optimization
   }
   auto end_regex = high_resolution_clock::now();

   // --- FastMatcher Benchmark ---
   auto start_glob = high_resolution_clock::now();
   {
       // No heavy compilation needed, just logic
       int matches = 0;
       for (const auto& s : dataset) {
           if (aria::glob::FastMatcher::match(s, pattern_str)) matches++;
       }
       volatile int keep = matches;
   }
   auto end_glob = high_resolution_clock::now();

   auto dur_regex = duration_cast<milliseconds>(end_regex - start_regex).count();
   auto dur_glob = duration_cast<milliseconds>(end_glob - start_glob).count();

   std::cout << "Results (100k strings):\n";
   std::cout << "std::regex:    " << dur_regex << " ms\n";
   std::cout << "FastMatcher:   " << dur_glob << " ms\n";
   std::cout << "Speedup Factor: " << (double)dur_regex / dur_glob << "x\n";
}

int main() {
   run_benchmark();
   return 0;
}

7.3 Theoretical Performance Analysis
Based on standard library implementation characteristics 5:
* std::regex: Requires memory allocation for the NFA graph. std::regex_match often involves virtual function calls or complex state transitions.
* FastMatcher: Zero heap allocation during match. The "Shifting Wildcard" logic is tight loops of character comparisons, highly amenable to CPU branch prediction.
Projected Results:
We anticipate FastMatcher to outperform std::regex by a factor of 10x to 50x in this specific filename matching use case. The difference is magnified in debug builds where std::regex iterators are heavily checked.
________________
8. Verification and Testing
To ensure reliability, we provide a comprehensive unit test suite covering edge cases, character classes, and recursive logic.
8.1 Source Code: tests/glob/test_glob_engine.cpp


C++




#include <iostream>
#include <cassert>
#include "glob/fast_matcher.h"
#include "glob/glob_pattern.h"

using namespace aria::glob;

void test_fast_matcher() {
   std::cout << " FastMatcher... ";
   
   // 1. Basic Wildcards
   assert(FastMatcher::match("main.cpp", "*.cpp") == true);
   assert(FastMatcher::match("main.cpp", "m??n.cpp") == true);
   assert(FastMatcher::match("test", "test") == true);
   
   // 2. Mismatches
   assert(FastMatcher::match("main.cpp", "*.h") == false);
   assert(FastMatcher::match("main.cpp", "main.????") == false); 

   // 3. Shifting Wildcard Logic (Backtracking)
   // pattern *a*b matching aaabbbaaabbb
   assert(FastMatcher::match("aaabbbaaabbb", "*a*b") == true);
   assert(FastMatcher::match("ab", "*a*b") == true);
   assert(FastMatcher::match("a", "*a*b") == false);

   // 4. Character Classes (The GAP Logic)
   assert(FastMatcher::match("a", "[abc]") == true);
   assert(FastMatcher::match("z", "[abc]") == false);
   assert(FastMatcher::match("b", "[a-z]") == true);  // Range
   assert(FastMatcher::match("1", "[a-z]") == false);
   
   // 5. Negation
   assert(FastMatcher::match("d", "[!abc]") == true);
   assert(FastMatcher::match("a", "[!abc]") == false);
   
   // 6. Edge Cases
   assert(FastMatcher::match("-", "[-]") == true);      // Dash literal
   assert(FastMatcher::match("]", "]") == true);      // Bracket literal
   
   std::cout << "PASSED\n";
}

void test_glob_pattern() {
   std::cout << " GlobPattern... ";
   
   GlobPattern p1("src/**/*.cpp");
   assert(p1.segments().size() == 3);
   assert(p1.segments().type == SegmentType::Recursive);
   
   // Anchor check
   assert(p1.get_anchor() == "src");
   
   // Normalization check (Windows style input)
   GlobPattern p2("src\\core\\*.h");
   assert(p2.get_anchor() == "src/core");

   std::cout << "PASSED\n";
}

int main() {
   test_fast_matcher();
   test_glob_pattern();
   return 0;
}

9. Conclusion
The AriaBuild Globbing Engine delivers a robust, high-performance file discovery mechanism that resolves the limitations of standard C++ libraries. By implementing the Shifting Wildcard algorithm and a custom parser, the system avoids regex compilation overhead and ensures semantically correct, deterministic builds across Windows and Unix platforms. The inclusion of GetFileAttributesW logic and timestamp-based caching ensures the tool is enterprise-ready, capable of handling large-scale repositories with minimal latency. This component is now fully specified and implemented, ready for integration into the core build loop.
Works cited
1. Why not seeing shell globs as a "dialect" of regex? - Unix & Linux Stack Exchange, accessed December 19, 2025, https://unix.stackexchange.com/questions/439875/why-not-seeing-shell-globs-as-a-dialect-of-regex
2. Glob vs. regex - Apify Blog, accessed December 19, 2025, https://blog.apify.com/glob-vs-regex/
3. gemini_gap_todo.txt
4. What are the differences between glob-style patterns and regular expressions?, accessed December 19, 2025, https://stackoverflow.com/questions/23702202/what-are-the-differences-between-glob-style-patterns-and-regular-expressions
5. Regex is comically slow. High performance alternatives? (Pattern matching for validation) : r/cpp_questions - Reddit, accessed December 19, 2025, https://www.reddit.com/r/cpp_questions/comments/yzqgm6/regex_is_comically_slow_high_performance/
6. glob (programming) - Wikipedia, accessed December 19, 2025, https://en.wikipedia.org/wiki/Glob_(programming)
7. glob(7) - Linux manual page - man7.org, accessed December 19, 2025, https://man7.org/linux/man-pages/man7/glob.7.html
8. `filesystem::exists` returns `false` for `c:\hiberfil.sys` · Issue #2370 · microsoft/STL - GitHub, accessed December 19, 2025, https://github.com/microsoft/STL/issues/2370
9. File Attribute Constants (WinNT.h) - Win32 apps | Microsoft Learn, accessed December 19, 2025, https://learn.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants
10. 44. Wildcard Matching - In-Depth Explanation, accessed December 19, 2025, https://algo.monster/liteproblems/44
11. Wildcard Pattern Matching in Linear Time and Constant Space - GeeksforGeeks, accessed December 19, 2025, https://www.geeksforgeeks.org/dsa/dynamic-programming-wildcard-pattern-matching-linear-time-constant-space/
12. Matching Wildcards - An Improved Algorithm for Big Data - Develop for Performance, accessed December 19, 2025, https://developforperformance.com/MatchingWildcards_AnImprovedAlgorithmForBigData.html
13. GetFileAttributesW function (fileapi.h) - Win32 apps | Microsoft Learn, accessed December 19, 2025, https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesw