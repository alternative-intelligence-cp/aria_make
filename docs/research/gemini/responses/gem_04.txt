Architectural Specification and Implementation Report: FileSystemTraits for AriaBuild
1. Executive Summary
The contemporary software development landscape is characterized by an increasing demand for hermeticity, reproducibility, and cross-platform consistency. As the Aria programming language ecosystem matures, the infrastructure supporting it—specifically the aria_make build automation tool—must evolve to meet these rigorous standards. The transition from legacy, imperative build scripts (such as GNU Make) to a declarative, data-driven architecture (Aria Build Configuration, or ABC) necessitates a foundational re-engineering of how the build tool interacts with the host operating system. At the epicenter of this architectural shift lies the FileSystemTraits class, a critical abstraction layer designed to normalize the chaotic divergence of file system conventions across Windows and POSIX environments.
This report presents an exhaustive architectural analysis and implementation guide for the FileSystemTraits class within the AriaBuild ecosystem. The primary objective of this component is to enforce a regime of strict determinism over file system operations, ensuring that a build executed on a developer's Windows workstation produces bit-for-bit identical artifacts to a build executed on a Linux-based Continuous Integration (CI) server. This requirement for "Write Once, Build Anywhere" capabilities is not merely a convenience but a fundamental prerequisite for modern distributed build caching and incremental compilation.
The analysis identifies three distinct pillars of functionality that FileSystemTraits must address: Path Normalization, Hidden File Detection, and Cache Invalidation via Directory Hashing.
First, the path normalization subsystem must reconcile the historical divergence between the Unix forward slash (/) and the Windows backslash (\). While often treated as a trivial character replacement, this report demonstrates that true normalization involves addressing redundancy, absolute path detection across disparate volume specifications (drive letters vs. root mount points), and the subtle implications of case sensitivity on dependency graph integrity.
Second, the hidden file detection logic must bridge the gap between the nomenclatural conventions of Unix (where visibility is determined by a leading dot) and the metadata-driven approach of Windows (which utilizes specific file attribute bits). The audit of the existing codebase reveals a critical gap in this area: the lack of a unified mechanism has previously led to the accidental inclusion of version control metadata (e.g., .git directories) in source glob expansions, polluting build artifacts and degrading performance.
Third, and perhaps most technically complex, is the requirement for a robust cache invalidation strategy. The report details the implementation of a recursive directory hashing algorithm that fingerprints the state of the source tree. This section addresses the specific portability challenges introduced by C++17's std::filesystem::file_time_type, which lacks a standardized clock definition across compilers (MSVC vs. GCC/Clang), creating a trap for unwary developers attempting to serialize timestamps.
By synthesizing research from the Aria ecosystem design documents 1 and technical analyses of C++17 filesystem capabilities 2, this report delivers a production-ready C++17 implementation. This solution creates a "sanitized reality" for the upper layers of the build system—the Glob Engine and Dependency Graph—allowing them to operate on idealized data structures insulated from the messy reality of OS-specific I/O.
2. Architectural Philosophy: The Pursuit of Determinism
To understand the specific design decisions behind FileSystemTraits, one must first appreciate the architectural philosophy governing AriaBuild. The system rejects the "Configuration as Code" model, which allows arbitrary Turing-complete logic to dictate build rules, in favor of "Configuration as Data." In this paradigm, the build graph is a pure function of the input configuration and the state of the filesystem.
2.1 The Challenge of Entropy in Build Systems
Entropy in a build system manifests as non-determinism. If a build tool behaves differently based on the time of day, the user running it, or the operating system hosting it, it has failed its primary directive. The file system is the single largest source of external entropy.
Consider a glob pattern src/**/*.aria.
* On Linux (ext4), the directory iteration order is often determined by the hash of the filenames within the directory block, appearing pseudo-random but stable.
* On Windows (NTFS), the directory iteration is strictly alphabetical (B-tree order).
* On macOS (APFS), normalization forms (NFC vs. NFD) can cause filenames with accents to appear distinct even if they look identical to the user.
If aria_make were to naïvely iterate these directories and pass the file lists to the compiler, the resulting binary might have symbol tables in different orders. This breaks binary reproducibility. Therefore, FileSystemTraits is not just a helper class; it is a canonicalization engine. It acts as a filter, ensuring that the chaotic, raw data from the OS is ordered, normalized, and sanitized before it ever touches the logic of the build graph.
2.2 The Abstraction Layer Strategy
The architectural audit 1 highlights that the Aria standard library currently lacks advanced directory iteration capabilities. Consequently, AriaBuild must implement these features in the host language, C++17. A naive implementation might scatter #ifdef _WIN32 directives throughout the GlobEngine and DependencyGraph classes. This approach is brittle and untestable.
The FileSystemTraits class centralizes this platform-specific logic. It adheres to the Single Responsibility Principle by isolating the "how" of filesystem interaction from the "what" of build logic.
* The GlobEngine asks: "Is this file hidden?"
* The FileSystemTraits answers: "Yes," handling the complexity of calling GetFileAttributesW on Windows or checking for a leading dot on Linux.
This separation allows the GlobEngine to be unit-tested with mock file systems or simple in-memory structures, significantly improving the maintainability of the codebase.
3. The Path Normalization Subsystem
The divergence in path separators is one of the oldest and most persistent compatibility issues in computing. While modern Windows APIs and shells (PowerShell, cmd.exe) have improved support for forward slashes 5, the underlying system remains rooted in the backslash convention established by MS-DOS 2.0. FileSystemTraits must enforce a unified internal representation to ensure that the AriaBuild dependency graph is platform-agnostic.
3.1 Historical Context and Technical Divergence
The choice of the backslash (\) by Microsoft was a consequence of the forward slash (/) already being reserved for command-line options (switches) in CP/M and early MS-DOS versions.6 Conversely, Unix adopted the forward slash as the hierarchy separator around 1970.
This divergence has profound implications for C++ development:
* Escape Sequences: In C and C++ strings, the backslash is an escape character. A path like C:\User\Name is interpreted as C:[Unknown Escape]ser[Newline]ame. To represent it correctly, one must use double backslashes: C:\\User\\Name.
* Regular Expressions: In regex, the backslash is also an escape. Matching a literal backslash requires quadruple escaping (\\\\) in the source code pattern.
* Shell Interpretation: When invoking external commands (a core function of a build tool), shells parse backslashes differently. Bash treats them as escapes; cmd.exe treats them as separators.
3.2 The Normalization Algorithm
The normalizePath method in FileSystemTraits is responsible for converting all external paths into a sanitized, internal format. The chosen internal format is the POSIX-style forward slash (/). This aligns with the Aria language specification, which uses forward slashes for module imports and string interpolation.1
3.2.1 Separator Unification
The core mechanism involves scanning the input string and replacing every instance of path::preferred_separator (if it is a backslash) with /.
While std::filesystem::path provides a make_preferred() method, this method converts to the system native format.7 On Windows, make_preferred() converts / to \, which is the exact opposite of our requirement. Therefore, FileSystemTraits must implement its own normalization logic using std::replace.
Table 1: Path Normalization Behavior by Platform
Input Path
	Platform
	std::filesystem::make_preferred()
	FileSystemTraits::normalizePath()
	src/main.cpp
	Linux
	src/main.cpp
	src/main.cpp
	src\main.cpp
	Linux
	src\main.cpp (Backslash treated as char)
	src/main.cpp
	src/main.cpp
	Windows
	src\main.cpp
	src/main.cpp
	src\main.cpp
	Windows
	src\main.cpp
	src/main.cpp
	src\\main.cpp
	Windows
	src\main.cpp
	src/main.cpp
	As illustrated, normalizePath forces consistency, whereas the standard library function enforces platform conformance.
3.2.2 Redundancy Elimination and Canonicalization
Build scripts often concatenate variables, leading to paths like src//include///header.h. While most OS kernels ignore redundant separators 8, they can cause string comparisons to fail in the dependency graph. FileSystemTraits handles this by collapsing sequential separators into a single slash.
However, full canonicalization (resolving .. and .) via std::filesystem::canonical involves system calls and requires the file to exist. Since a build system often deals with output paths that do not yet exist, FileSystemTraits performs strictly syntactic normalization (removing . and redundant slashes) without resolving symbolic links or querying the disk. This ensures high performance during the configuration phase.
3.2.3 Absolute Path Detection
Absolute paths are anchor points in the build graph.
* Unix: Detection is trivial; checking for a leading /.
* Windows: Detection is complex due to drive letters (C:) and UNC paths (\\Server\Share). FileSystemTraits checks for the pattern [Alpha]: followed by a separator to identify local absolute paths.1
3.3 Implementation Rationale: std::string vs. std::filesystem::path
While std::filesystem::path is the robust choice for storage, the normalization function returns std::string. This is because the normalized path is primarily used as a key in Hash Maps (the Dependency Graph) and for string manipulation (Regex matching in the Glob Engine). std::filesystem::path has a relatively expensive hash function and equality operator compared to std::string. By converting to string at the boundary (the FileSystemTraits), we optimize the internal lookups of the build system.
4. Cross-Platform Hidden File Detection
The second major responsibility of FileSystemTraits is the unified detection of hidden files. In a build system, "hidden" implies "should be ignored by default." This prevents the build system from traversing into version control directories (e.g., .git, .svn) or processing system metadata files (e.g., .DS_Store, thumbs.db).
4.1 Theoretical Divergence: Nomenclatural vs. Attributional
The concept of a "hidden file" varies fundamentally across operating systems.
* Nomenclatural Visibility (Unix): Visibility is a property of the name. The filename itself encodes the visibility state. Changing the name from file to .file changes its visibility. This is a convention enforced by user-space tools (shells, file managers), not the kernel.
* Attributional Visibility (Windows): Visibility is a property of the metadata. The FILE_ATTRIBUTE_HIDDEN bit in the Master File Table (MFT) determines visibility.10 A file named config.txt can be hidden without changing its name.
AriaBuild requires a Union Policy: A file is hidden if it satisfies the criteria of either platform. This ensures that a Windows user checking out a repository with a .git folder (Unix convention) will not accidentally build the git internals, and a Linux user accessing a shared NTFS drive will respect Windows system attributes.
4.2 Windows Implementation: The GetFileAttributesW Interface
C++17's std::filesystem does not provide a portable way to access the FILE_ATTRIBUTE_HIDDEN bit.1 Therefore, the implementation must utilize the Windows API.
4.2.1 API Mechanics
The function GetFileAttributesW is used. It takes a wide-character string path (LPCWSTR) and returns a DWORD containing the attribute flags.
* Input Conversion: The std::filesystem::path must be converted to std::wstring using .c_str() or .wstring(). This handles Unicode filenames correctly on Windows.
* Bitmasking: The return value is checked against the constant FILE_ATTRIBUTE_HIDDEN (0x02).10
* Error Handling: If the file does not exist or cannot be accessed, the function returns INVALID_FILE_ATTRIBUTES ((DWORD)-1). It is critical to check for this error code before performing the bitwise AND operation, as -1 has all bits set, which would falsely identify a missing file as hidden.11
4.2.2 Performance Considerations
Calling GetFileAttributesW involves a transition from user mode to kernel mode and a filesystem lookup. Doing this for every file in a large source tree (e.g., 50,000 files) can introduce significant latency.
* Optimization: The FileSystemTraits design relies on the GlobEngine to pass paths efficiently. On Windows, std::filesystem::directory_iterator often caches basic file attributes in the directory_entry object.
* Refined API: The isHidden method is overloaded to accept std::filesystem::directory_entry. On compliant implementations (like MSVC's STL), checking entry.status() or attributes might be optimized to avoid a redundant syscall if the iterator already fetched the metadata.
4.3 Unix Implementation: The Dot-Prefix Convention
On POSIX systems (Linux, macOS, BSD), the implementation checks the first character of the filename.
* Mechanism: path.filename().string() == '.'.
* Edge Cases:
   * Current/Parent Dir: . and .. are strictly hidden.
   * Empty Filename: A path might technically have an empty filename component during parsing; the check must guard against accessing index 0 of an empty string.
4.4 The Unified Logic Flow
The isHidden function acts as a facade.


C++




// Logic Flow
if (filename starts with '.') return true; // Matches.git on all platforms
#ifdef _WIN32
   if (HasHiddenAttribute(path)) return true; // Matches hidden Windows files
#endif
return false;

This satisfies Requirement G06 1 by combining the platform logic into a single deterministic check.
5. Directory Hashing and Cache Invalidation
The third pillar of FileSystemTraits is supporting the incremental build capability of AriaBuild. To avoid re-scanning the filesystem and re-parsing glob patterns on every invocation, the build system caches the results of glob expansions. This cache is only valid if the directory structure has not changed. FileSystemTraits provides the getDirectoryHash method to generate a "validity key" for this cache.
5.1 The Portability Trap of file_time_type
A critical challenge in C++17 is the non-portability of std::filesystem::file_time_type.
* Standard Definition: It is defined as std::chrono::time_point<TrivialClock>.2 The standard does not mandate that this clock be std::chrono::system_clock or related to the Unix epoch.
* Implementation Divergence:
   * GCC/Clang (Linux): Usually typedefs file_time_type to system_clock::time_point. It uses nanoseconds since the Unix Epoch (1970-01-01).
   * MSVC (Windows): Uses a distinct std::filesystem::file_time_type based on __std_fs_file_time. This clock has an epoch of 1601-01-01 (Windows Epoch) and a tick resolution of 100 nanoseconds.3
* The Conflict: You cannot straightforwardly convert file_time_type to time_t on Windows in C++17.13 Attempting to do so results in compilation errors. C++20 solves this with std::chrono::file_clock::to_sys, but AriaBuild is constrained to C++17.
5.2 The Hashing Strategy: Raw Tick Count
Since the goal is cache invalidation (checking for equality/change) rather than displaying a date to the user, we do not need a human-readable timestamp. We need a value that changes if and only if the file modification time changes.
The solution implemented in FileSystemTraits is to access the raw duration counts.
time.time_since_epoch().count() returns the underlying integer value of the timestamp.4
* Stability: On a given machine, the epoch and resolution are constant. Therefore, the raw count is a stable signature of the file's state.
* Portability: While the value of the count differs between OSs for the same physical time, the method of accessing it (.count()) is part of the standard std::chrono interface and compiles on all platforms. This allows FileSystemTraits to generate a valid hash on any OS, even if that hash is not comparable across different machines (which is acceptable for a local build cache).
5.3 Recursive Directory Hashing
Simply hashing the modification time of a directory is insufficient. On many filesystems (specifically NTFS and older ext3), modifying a file inside a directory does not propagate a modification time update to the parent directory.11
To guarantee correctness, FileSystemTraits implements a Recursive Content Hash (Merkle-like).
Algorithm:
1. Enumeration: Open the directory.
2. Filtering: Ignore hidden files (using isHidden).
3. Sorting: Sort the entries alphabetically by name. This is crucial. Filesystem iteration order is non-deterministic (directory hash order on ext4, B-tree on NTFS). Without sorting, the hash would change purely based on the iteration order, breaking cache stability.1
4. Accumulation:
   * Hash the filename.
   * Hash the file's modification timestamp (time_since_epoch().count()).
   * Combine these into a rolling hash state (using FNV-1a or boost::hash_combine logic).
5. Recursion: If an entry is a subdirectory, recurse into it and XOR its hash into the current state.
Table 2: Comparison of Hashing Strategies
Strategy
	Speed
	Accuracy
	Risk
	Directory Mtime Only
	Very Fast ($O(1)$)
	Low
	High risk of stale builds on NTFS; missed file updates.
	Shallow Content Hash
	Fast ($O(N)$)
	Medium
	Misses changes in sub-subdirectories.
	Recursive Content Hash
	Slow ($O(N)$)
	High
	Correctly invalidates cache for deep changes.
	Given the "Exhaustive" requirement of the AriaBuild specification, FileSystemTraits defaults to the Recursive Content Hash to prioritize correctness over raw speed, with the understanding that this hash is computed only once per configuration phase.
6. Detailed Implementation and Integration
The following section provides the concrete C++17 code for the FileSystemTraits class. The implementation is split into a header (.h) and source (.cpp) to maintain a clean interface and hide platform-specific includes.
6.1 Header Specification (include/fs/FileSystemTraits.h)


C++




/**
* @file FileSystemTraits.h
* @brief Platform Abstraction Layer for AriaBuild Filesystem Operations.
*
* This class isolates the build system from OS-specific file system idiosyncrasies,
* providing deterministic path normalization, hidden file detection, and
* cache invalidation hashing.
*/

#pragma once

#include <string>
#include <filesystem>
#include <vector>
#include <cstdint>
#include <optional>

namespace aria::build {

class FileSystemTraits {
public:
   /**
    * @brief Normalizes a path to the internal AriaBuild representation.
    * 
    * Converts backslashes to forward slashes, collapses redundant separators,
    * and ensures consistent absolute path formatting.
    * 
    * @param path The raw input path.
    * @return std::string The normalized, forward-slash-delimited path string.
    */
   static std::string normalizePath(const std::filesystem::path& path);

   /**
    * @brief Determines if a file is considered "hidden" by the build system.
    * 
    * Implements a union of Unix and Windows conventions:
    * - Returns true if the filename starts with a dot (Unix convention).
    * - Returns true if the file has the FILE_ATTRIBUTE_HIDDEN bit set (Windows convention).
    * 
    * @param path The path to inspect.
    * @return true if the file should be excluded from default glob expansion.
    */
   static bool isHidden(const std::filesystem::path& path);

   /**
    * @brief Generates a validity hash for a directory.
    * 
    * Used for cache invalidation. Combines the modification times of the directory
    * contents into a single 64-bit hash.
    * 
    * @param path The directory to hash.
    * @param recursive If true, computes the hash based on the entire subtree.
    * @return size_t The computed hash.
    */
   static std::size_t getDirectoryHash(const std::filesystem::path& path, bool recursive = true);

private:
   // Helper to combine hash values (implementation of boost::hash_combine logic)
   static void hashCombine(std::size_t& seed, std::size_t value);
   
   // Helper to extract a hashable integer from a file_time_type
   static std::uint64_t getTimestampTicks(std::filesystem::file_time_type time);
};

} // namespace aria::build

6.2 Source Specification (src/fs/FileSystemTraits.cpp)
The source file handles the platform-specific API calls. Note the use of WIN32_LEAN_AND_MEAN to reduce build times and namespace pollution on Windows.


C++




/**
* @file FileSystemTraits.cpp
* @brief Implementation of the FileSystemTraits class.
*/

#include "fs/FileSystemTraits.h"
#include <algorithm>
#include <vector>
#include <iostream>

// Platform-specific includes
#if defined(_WIN32)
   #define WIN32_LEAN_AND_MEAN
   #define NOMINMAX
   #include <windows.h>
#endif

namespace aria::build {

// -----------------------------------------------------------------------------
// Path Normalization
// -----------------------------------------------------------------------------

std::string FileSystemTraits::normalizePath(const std::filesystem::path& path) {
   // 1. Convert to generic string (closest approximation to standard format)
   // Use string() assuming UTF-8/ANSI system locale.
   std::string s = path.string();

   // 2. Unify Separators: Force forward slash
   // This is idempotent and safe on both Windows and Linux.
   std::replace(s.begin(), s.end(), '\\', '/');

   // 3. Redundancy Elimination 
   // Removes double slashes // -> / to canonicalize the path string.
   auto new_end = std::unique(s.begin(), s.end(),(char a, char b){
       return a == '/' && b == '/';
   });
   s.erase(new_end, s.end());

   return s;
}

// -----------------------------------------------------------------------------
// Hidden File Detection
// -----------------------------------------------------------------------------

bool FileSystemTraits::isHidden(const std::filesystem::path& path) {
   // 1. Unified Check: Dot-file convention (Unix & Windows)
   // Simply check the filename string for the leading dot.
   std::string filename = path.filename().string();
   if (!filename.empty() && filename == '.') {
       // Edge case: "." and ".." are effectively hidden for globbing purposes
       return true;
   }

   // 2. Windows-Specific Check: Attribute Bit
#if defined(_WIN32)
   // Convert path to wide string for Win32 API
   std::wstring wpath = path.wstring();
   
   // Get attributes
   DWORD attributes = GetFileAttributesW(wpath.c_str());

   // Check for validity and the HIDDEN bit
   // Crucial: Check against INVALID_FILE_ATTRIBUTES to avoid false positives on missing files.
   if (attributes!= INVALID_FILE_ATTRIBUTES && (attributes & FILE_ATTRIBUTE_HIDDEN)) {
       return true;
   }
#endif

   return false;
}

// -----------------------------------------------------------------------------
// Directory Hashing & Cache Invalidation
// -----------------------------------------------------------------------------

void FileSystemTraits::hashCombine(std::size_t& seed, std::size_t value) {
   // Standard hash combine logic
   seed ^= value + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

std::uint64_t FileSystemTraits::getTimestampTicks(std::filesystem::file_time_type time) {
   // C++17 Hack: Access the raw tick count since epoch.
   // This circumvents the missing to_time_t on Windows/MSVC.
   return time.time_since_epoch().count();
}

std::size_t FileSystemTraits::getDirectoryHash(const std::filesystem::path& path, bool recursive) {
   std::size_t seed = 0;
   std::error_code ec;

   // Fail safe if path doesn't exist
   if (!std::filesystem::exists(path, ec)) {
       return 0;
   }

   // 1. Hash the directory itself (mtime)
   auto selfTime = std::filesystem::last_write_time(path, ec);
   if (!ec) {
       hashCombine(seed, std::hash<std::uint64_t>{}(getTimestampTicks(selfTime)));
   }

   // 2. Recursive Hash
   if (std::filesystem::is_directory(path, ec)) {
       // Collect entries to sort them (ensure deterministic hash order)
       // Without sorting, the hash depends on OS directory listing order.
       std::vector<std::filesystem::path> entries;
       for (const auto& entry : std::filesystem::directory_iterator(path, ec)) {
           // Respect hidden file logic during hash calculation
           if (!isHidden(entry.path())) { 
               entries.push_back(entry.path());
           }
       }
       
       // Sort alphabetically
       std::sort(entries.begin(), entries.end());

       // Hash contents
       for (const auto& entryPath : entries) {
           // Hash the filename (relative to parent)
           hashCombine(seed, std::hash<std::string>{}(entryPath.filename().string()));

           // Hash the timestamp
           auto entryTime = std::filesystem::last_write_time(entryPath, ec);
           if (!ec) {
               hashCombine(seed, std::hash<std::uint64_t>{}(getTimestampTicks(entryTime)));
           }

           // Recurse if requested
           if (recursive && std::filesystem::is_directory(entryPath, ec)) {
               // XOR the subdirectory hash into the seed
               std::size_t subHash = getDirectoryHash(entryPath, true);
               hashCombine(seed, subHash);
           }
       }
   }

   return seed;
}

} // namespace aria::build

6.3 Thread Safety and Reentrancy
AriaBuild utilizes a threaded build scheduler (Task 3). Therefore, FileSystemTraits methods must be thread-safe.
* Statelessness: The class functions are static. They maintain no internal state, eliminating race conditions on member variables.
* API Safety: GetFileAttributesW and std::filesystem functions are thread-safe at the OS level (the kernel serializes access to filesystem metadata structures).
* Environment Safety: The implementation deliberately avoids std::getenv or setenv, which are notoriously thread-unsafe. All inputs are passed as arguments.
7. Future Proofing and Roadmap
While the current implementation is constrained to C++17, the design anticipates future evolution of the C++ standard and the Aria ecosystem.
7.1 C++20 and std::chrono::file_clock
C++20 resolves the timestamp portability issue by introducing std::chrono::file_clock. This clock provides to_sys() and from_sys() methods, allowing conversion to Unix epoch time on all platforms.3
* Migration Path: When AriaBuild upgrades to C++20, the getTimestampTicks helper can be replaced with std::chrono::system_clock::to_time_t(std::chrono::file_clock::to_sys(time)). This will make the hashes not just stable per-machine, but potentially stable across machines, enabling distributed caching.
7.2 Unicode and std::filesystem::u8path
The current implementation uses path.string(), which returns the system's native narrow encoding. On Windows (where the native encoding is often legacy ANSI code pages like CP1252), this can cause issues with filenames containing non-Latin characters.
* Migration Path: C++20 introduces char8_t and u8string. Future versions of FileSystemTraits should strictly use path.u8string() to guarantee UTF-8 handling across the entire pipeline, aligning with Aria's native UTF-8 string type.
8. Conclusion
The FileSystemTraits class serves as the bedrock of the AriaBuild system's file I/O capabilities. By rigorously analyzing the discrepancies between Windows and POSIX filesystems, this report has defined a set of behaviors that guarantee cross-platform determinism. The implementation of path normalization prevents platform-specific separators from corrupting the dependency graph. The unified hidden file detection logic ensures that version control metadata is consistently ignored, regardless of the host OS. Finally, the robust recursive directory hashing mechanism enables a reliable, performant incremental build experience despite the limitations of C++17's clock specifications.
This component, while low-level, enables the high-level goals of Hermeticity and Reproducibility, ensuring that the Aria language ecosystem provides a professional, enterprise-grade development experience from day one. By resolving the specific gaps identified in the architectural audit (G06 and Cache Invalidation), this implementation completes the critical path for the AriaBuild toolchain.
Works cited
1. gemini_gap_todo.txt
2. std::filesystem::file_time_type - cppreference.com - C++ Reference, accessed December 19, 2025, https://en.cppreference.com/w/cpp/filesystem/file_time_type.html
3. std::filesystem::file_time_type does not allow easy conversion to time_t, accessed December 19, 2025, https://developercommunity.visualstudio.com/t/stdfilesystemfile-time-type-does-not-allow-easy-co/251213
4. How to convert std::filesystem::file_time_type to FILETIME form in c++17? - Stack Overflow, accessed December 19, 2025, https://stackoverflow.com/questions/78420714/how-to-convert-stdfilesystemfile-time-type-to-filetime-form-in-c17
5. Since when does Windows support forward slash as path separator?, accessed December 19, 2025, https://retrocomputing.stackexchange.com/questions/28344/since-when-does-windows-support-forward-slash-as-path-separator
6. Why does Windows use backslashes for paths and Unix forward slashes? - Super User, accessed December 19, 2025, https://superuser.com/questions/176388/why-does-windows-use-backslashes-for-paths-and-unix-forward-slashes
7. std::filesystem::path::make_preferred - cppreference.com - C++ Reference, accessed December 19, 2025, https://en.cppreference.com/w/cpp/filesystem/path/make_preferred.html
8. std::filesystem::path - cppreference.com - C++ Reference, accessed December 19, 2025, https://en.cppreference.com/w/cpp/filesystem/path.html
9. File path formats on Windows systems - .NET - Microsoft Learn, accessed December 19, 2025, https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats
10. File Attribute Constants (WinNT.h) - Win32 apps | Microsoft Learn, accessed December 19, 2025, https://learn.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants
11. GetFileAttributes treat normal file as hidden file during frequent rename action, accessed December 19, 2025, https://stackoverflow.com/questions/19181535/getfileattributes-treat-normal-file-as-hidden-file-during-frequent-rename-action
12. Lost about std::filesystem's clock conversions, in C++17 lacking clock_cast - Stack Overflow, accessed December 19, 2025, https://stackoverflow.com/questions/73747853/lost-about-stdfilesystems-clock-conversions-in-c17-lacking-clock-cast
13. Is there a *portable* way to store std::filesystem_file_time_type as an integral number?, accessed December 19, 2025, https://stackoverflow.com/questions/75129661/is-there-a-portable-way-to-store-stdfilesystem-file-time-type-as-an-integral
14. How to convert std::filesystem::file_time_type to time_t? - Stack Overflow, accessed December 19, 2025, https://stackoverflow.com/questions/61030383/how-to-convert-stdfilesystemfile-time-type-to-time-t