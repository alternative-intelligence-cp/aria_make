CLI Driver Architecture for aria_make Build System
1. Executive Summary and Strategic Architectural Context
The progression of the Aria programming language from its experimental prototyping phases toward a mature, systems-grade ecosystem necessitates a fundamental transformation in its build infrastructure. As the language specification stabilizes around version 0.0.7, incorporating advanced features such as Twisted Balanced Binary (TBB) arithmetic and a hybrid memory model, the ad-hoc compilation scripts of the past have become a liability. They lack the determinism, scalability, and ergonomic sophistication required for modern software engineering. This report articulates the comprehensive architectural specification for aria_make (internally designated as AriaBuild), a dedicated Command Line Interface (CLI) driver designed to orchestrate the entire lifecycle of Aria software artifacts.
The architecture of aria_make is predicated on the "Meta-Driver" paradigm. Unlike monolithic compilers that attempt to manage project structure internally, or imperative build scripts that entangle configuration with execution logic, aria_make functions as a high-level orchestrator. It occupies the strategic layer between the developer's intent—expressed through a declarative, whitespace-insensitive configuration format—and the mechanical realities of the toolchain, comprising the ariac compiler and the lli runtime environment.1 The driver is engineered to enforce strict determinism, ensuring that a build executed on a developer's workstation produces bit-identical artifacts to one executed in a CI/CD pipeline, regardless of the underlying operating system's filesystem idiosyncrasies or environment variable permutations.
This specification synthesizes best-in-class practices from the build system landscape—drawing on the dependency resolution graphs of Ninja, the user-facing ergonomics of Cargo, and the installation semantics of CMake—while addressing the unique constraints of the Aria runtime. Specifically, the driver handles the language's lack of native directory iteration by implementing a robust C++17 globbing subsystem 1, manages the "Six-Stream" I/O topology native to Aria processes 1, and provides a rigorous subcommand architecture based on the CLI11 library to separate concerns between building, testing, cleaning, and deployment.
2. Theoretical Foundations: The Meta-Driver Paradigm
To understand the necessity of aria_make, one must first deconstruct the limitations of direct compiler invocation. The ariac compiler is a translation engine; its scope is limited to transforming a single compilation unit (or a unified stream of source code) into an intermediate representation (LLVM IR). It accepts flags like -o for output and -I for include paths, but it possesses no inherent knowledge of the broader project structure, dependency topology, or incremental state.1
The "Meta-Driver" architecture fills this void by introducing a stateful supervisor. aria_make parses the project intent, resolves the dependency graph, calculates the "dirtiness" of targets based on filesystem timestamps, and then synthesizes the precise sequence of ariac invocations required to bring the system to the desired state.1 This separation of concerns allows the compiler to remain stateless and pure, while the build tool manages the complexity of the environment.
2.1 The Imperative of Determinism
In systems programming, non-determinism is a critical failure mode. If the order in which source files are linked changes due to the vagaries of the filesystem, the resulting binary checksum changes, breaking reproducibility. aria_make enforces determinism through three primary mechanisms:
1. Lexicographical Input Sorting: Filesystems like ext4 (Linux) and NTFS (Windows) return directory listings in different orders (hash-based vs. B-tree based). The aria_make driver buffers all file lists generated by globbing patterns and strictly sorts them alphabetically before passing them to the compiler. This ensures that the linkage order is invariant across platforms.1
2. Environment Hermeticity: The driver controls the leakage of environment variables into the build context. While it supports explicit interpolation via &{ENV.VAR}, it does not implicitly forward the entire parent environment to the build logic, preventing "works on my machine" syndromes caused by hidden configuration.1
3. Path Normalization: Internal logic normalizes all filesystem paths to use forward slashes, abstracting away the Windows backslash separator to ensure that configuration files and dependency hashes remain portable.1
2.2 The Whitespace-Insensitive Configuration Strategy
A profound architectural decision for aria_make is the rejection of significant whitespace. Legacy tools like GNU Make rely on the distinction between tabs and spaces, a design choice that violates the Principle of Least Astonishment and introduces invisible syntax errors. The Aria Build Configuration (ABC) format adopts a JSON-derivative syntax that uses structural delimiters (braces and brackets) to define scope.1 This allows the CLI driver to parse configurations that are minified, auto-generated, or heavily indented without semantic ambiguity, prioritizing "Configuration as Data" over "Configuration as Code."
3. CLI Library Selection and Subcommand Architecture
The implementation of a robust CLI driver requires a sophisticated argument parsing library. The complexity of modern build tools—which must handle global flags (verbosity, jobs), subcommands (build, test, install), and command-specific flags—exceeds the capabilities of simple getopt or manual argv parsing.
3.1 Library Analysis and Selection: The Case for CLI11
A comparative analysis of the C++ ecosystem reveals several candidates: Boost.Program_options, cxxopts, argparse, and CLI11.
* Boost.Program_options: While powerful, it introduces a heavy dependency on the Boost libraries. For a build tool intended to be a "batteries-included" part of the language distribution, minimizing external dynamic linkage is preferred to ease bootstrapping.2
* cxxopts: This library is lightweight and header-only but lacks deep support for nested subcommands, making it unsuitable for the multi-verb architecture required by aria_make.4
* CLI11: This library is identified as the optimal choice. It is a single-header C++11/17 library that supports infinite subcommand nesting, type-safe argument binding, and advanced help formatting.4 Crucially, its design allows for the definition of distinct App instances for each subcommand, enabling strict isolation of validation logic. For instance, the install command can require a --prefix flag that is irrelevant to the clean command.6
3.2 Subcommand Hierarchy and Semantics
The aria_make driver is structured around a verb-noun grammar. The root application handles global settings, while subcommands define the specific lifecycle operation.
Subcommand
	Description
	Key Flags
	Behavioral Logic
	build
	Compiles the project. Default if no command is given.
	--mode <fast/safe>, --debug-macro, -j <jobs>
	Constructs the DAG, resolves dependencies, and orchestrates ariac.
	test
	Runs test suites defined in the configuration.
	--filter <pattern>, --verbose
	Builds test targets and executes them via lli, capturing exit codes.
	clean
	Removes generated artifacts.
	--target <name>, --all
	Traverses the DAG to delete output files and clear globbing caches.
	install
	Deploys artifacts to system locations.
	--prefix <path>, --destdir <path>
	Copies compiled binaries/libs to destination paths compliant with packaging standards.
	run
	Builds and executes a binary target.
	--args "..."
	Convenience wrapper for the build-then-execute cycle.
	3.3 Global Flag Architecture
Certain flags operate globally, affecting the behavior of the driver regardless of the subcommand.
* Verbosity (-v, --verbose): Controls the logging level of the meta-driver. In verbose mode, aria_make prints the exact command lines being passed to ariac, which is essential for debugging toolchain issues.1
* Jobs (-j, --jobs): Controls the parallelism of the build. The driver utilizes a thread pool to execute independent nodes of the dependency DAG concurrently. The default is typically set to std::thread::hardware_concurrency().
* Configuration (--config): Overrides the default search path for build.aria or aria.json, allowing the tool to build projects from non-standard locations.
4. Configuration Parsing and The ABC Language
The heart of the aria_make driver is the parser responsible for ingesting the Aria Build Configuration (ABC). This parser transforms the raw text of the configuration file into a structured C++ object model that represents the build plan.
4.1 Input Resolution and Schema Validation
Upon invocation, the driver scans the current working directory for build.aria or aria.json.1 The parser reads the file into memory and tokenizes it using the whitespace-insensitive lexer rules defined in the architecture.1
The parsed data is validated against a rigorous schema:
* project: Metadata (name, version).
* variables: A symbol table for string constants.
* targets: A list of build artifacts.
This validation step ensures type safety before any filesystem modification occurs. For example, it confirms that sources is a list of strings and type is a valid enumeration (binary, library, script, test).1
4.2 The Variable Interpolation Engine
To provide the flexibility of a scripting language without the non-determinism, aria_make implements a recursive variable interpolation engine. The driver scans all string values for the &{...} marker.1 The resolution logic follows a strict hierarchy:
   1. Local Scope: Variables defined within the specific target definition override all others.
   2. Global Scope: Variables defined in the root variables block.
   3. Environment Scope: Variables prefixed with ENV. (e.g., &{ENV.HOME}) are resolved against the host operating system's environment block.1
This hierarchical resolution is performed prior to glob expansion, allowing users to define dynamic paths such as sources: ["&{src_dir}/*.aria"]. The engine creates a fully resolved "effective configuration" in memory, which serves as the immutable source of truth for the build session.
4.3 The Deterministic Globbing Subsystem
A critical responsibility of the CLI driver is file discovery. Since the Aria runtime library lacks directory iteration capabilities, aria_make implements this in the C++ host layer.1
   * Syntax: The globber supports * (segment wildcard), ** (recursive wildcard), ? (single char), and character classes [...].1
   * Operational Modes:
   * Safe Mode (Default): The driver traverses the physical filesystem using std::filesystem::recursive_directory_iterator. It collects matches, filters exclusions (e.g., tests/** 1), and then performs the mandatory alphabetic sort to guarantee determinism.
   * Fast Mode: To optimize startup time for large repositories, the driver can compute a hash of the glob patterns. If a cached manifest exists for that hash, the driver loads the file list from disk, bypassing the slow filesystem traversal.1 This trade-off between speed and correctness is controlled via the --mode flag.
5. The Dependency Graph and Execution Engine
Once the configuration is parsed and files are discovered, the driver constructs the build plan. This is modeled as a Directed Acyclic Graph (DAG) where nodes represent targets and edges represent dependencies.
5.1 DAG Construction and Topological Sorting
The driver iterates through the targets list. For each target, it examines the depends_on field to create directed edges to other targets.
   * Kahn's Algorithm: The driver employs Kahn's Algorithm to perform a topological sort of the DAG. This algorithm identifies nodes with zero incoming edges (dependencies that are already built or have no dependencies) and adds them to a processing queue. It creates a linear execution schedule that respects the dependency order.1
   * Cycle Detection: A robust build system must handle errors gracefully. If Kahn's algorithm fails to consume all nodes, a circular dependency exists. The driver then initiates a Depth First Search (DFS) on the residual graph to detect the cycle path (e.g., Module A -> Module B -> Module A). This path is reported to the user as a descriptive error, preventing infinite recursion or hangs.1
5.2 Incremental Build Logic
To minimize build times, aria_make implements incremental compilation logic. For each target in the execution schedule, the driver performs a "Dirtiness Check":
   1. Output Timestamp ($T_{out}$): It queries the modification time of the target's output file (e.g., bin/main.ll) using std::filesystem::last_write_time.
   2. Input Timestamps ($T_{in}$): It queries the modification times of all resolved source files and dependency artifacts.
   3. Comparison: If $T_{out}$ is missing, or if any $T_{in} > T_{out}$, the target is marked Dirty.1
Only dirty targets are passed to the orchestration engine; clean targets are skipped, significantly accelerating the development loop.
6. Toolchain Orchestration Strategy
The orchestration engine is the interface between the abstract build plan and the concrete operating system processes. It translates the internal representation of a target into a command-line invocation of the toolchain.
6.1 Compiler Invocation (ariac)
For targets requiring compilation, the driver constructs a command vector for the ariac binary.
      * Output Mapping: The output field from the configuration is mapped to the -o flag.1 The driver ensures the parent directory exists before execution.
      * Include Paths: Dependencies are crucial here. The driver resolves the output directory of every target listed in depends_on and appends it as an -I (include) flag. This ensures that the compiler can locate the headers or module definitions of the dependencies.1
      * Debug Macros: If the --debug-macro flag was passed to the CLI, the driver appends -E to the ariac command. This instructs the compiler to stop after preprocessing, outputting the expanded source code (e.g., preprocessed.aria). This feature is vital for debugging complex macro logic without triggering backend compilation errors.1
6.2 Runtime Invocation (lli)
For targets of type binary, compilation produces an LLVM IR file (.ll). To run this artifact (e.g., during a test or run command), the driver invokes the LLVM interpreter lli.
      * Process Isolation: The driver spawns lli as a child process, passing the compiled .ll file as the argument.1
      * Signal Handling: The driver acts as a supervisor, forwarding signals (like SIGINT/Ctrl+C) to the child process to ensure clean termination of the runtime environment.
6.3 The Six-Stream I/O Topology
A unique aspect of the Aria ecosystem is its six-stream I/O model. While standard systems use 3 streams (stdin, stdout, stderr), Aria adds stddbg (debug logs), stddati (data in), and stddato (data out).1
      * Driver Responsibility: When aria_make spawns a process (either ariac or a compiled binary via lli), it must respect this topology.
      * Routing: The driver typically pipes stdout and stderr to the user's console (often with buffering to prevent interleaving in parallel builds). stddbg might be routed to a log file or a separate verbose console stream if requested. stddati and stddato are typically reserved for pipeline composition, but the build driver ensures these descriptors (FD 3, 4, 5) are managed correctly according to the kernel-level specification.1
7. Lifecycle Management: Clean and Install
While the core build logic is well-defined, a complete toolchain requires management of the entire artifact lifecycle. Based on standard build system semantics (Make, CMake, Cargo), aria_make implements the following logic for clean and install commands.
7.1 The clean Architecture
The clean command addresses the problem of artifact pollution. Stale object files or binaries can cause linking errors or false positives in testing.
      * Targeted Clean: aria_make clean <target>
      * The driver looks up the target in the graph.
      * It resolves the absolute path of the output artifact.
      * It calls std::filesystem::remove.
      * Global Clean: aria_make clean
      * The driver traverses the entire DAG.
      * It deletes the output of every node.
      * Cache Purge: Crucially, it also deletes the globbing cache manifest used by "Fast Mode." This forces the next build to perform a completely fresh scan of the filesystem, resolving any discrepancies between the cached state and the physical disk state.
7.2 The install Architecture
The install command moves artifacts from the development environment to the system deployment locations. This is essential for distributing libraries and executables.
      * Path Semantics: The driver adheres to the GNU standard variables for installation paths.8
      * PREFIX: The root of the installation (default: /usr/local on Linux, C:\Program Files on Windows).
      * DESTDIR: A staging directory prepended to the prefix, used by package managers (e.g., rpmbuild, dpkg) to capture installed files without polluting the host system.
      * Execution Logic:
      1. The driver identifies targets marked for installation (e.g., via an install: true flag in the target config, or implicitly for all binary and library types).
      2. It calculates the destination path: FinalPath = ${DESTDIR}/${PREFIX}/bin/${TargetName}.
      3. It ensures the destination directory exists.
      4. It performs a file copy, preserving execution permissions (chmod +x).
      5. It reports the installation actions to stdout (e.g., "Installing bin/myapp to /usr/local/bin/myapp").
8. Testing and Quality Assurance
The test subcommand transforms aria_make into a test runner, integrating verification into the build loop.
8.1 Test Discovery and Execution
      * Target Identification: The driver filters the target list for items with type: test.1
      * Dependency handling: Before running a test, the driver ensures the test binary itself is built and up-to-date.
      * Execution: The driver invokes lli <test_binary.ll>.
      * Result Parsing: It captures the exit code of the lli process.
      * 0: Pass.
      * Non-Zero: Fail.
      * Reporting: The driver aggregates results and prints a summary (e.g., "5 Tests Passed, 1 Failed"). If a test fails, it prints the captured stderr output of that specific test to aid debugging.
8.2 Integration with AriaLS
The build system serves as the source of truth for the Aria Language Server (AriaLS). The aria_make driver can generate a compile_commands.json (or similar manifest) that details the include paths and flags for every file. This allows the Language Server to correctly index the project, resolving dependencies and providing accurate IntelliSense features.1
9. Conclusion
The architecture of the aria_make CLI driver represents a rigorous application of modern systems engineering principles to the domain of build automation. By adopting the "Meta-Driver" pattern, it effectively decouples the high-level intent of project configuration from the low-level mechanics of compilation. The use of a declarative, whitespace-insensitive configuration format (ABC) resolves longstanding usability issues associated with legacy tools, while the implementation of a C++17-based globbing and dependency engine ensures performance and cross-platform determinism.
Furthermore, the integration of advanced lifecycle management—including incremental builds, cycle detection, and standardized clean/install workflows—positions aria_make not merely as a wrapper for ariac, but as a complete project manager. The driver's awareness of Aria's unique features, such as the six-stream I/O topology and macro preprocessing modes, ensures that it provides a cohesive and powerful developer experience that scales from simple scripts to complex, multi-module system applications. This architecture provides the solid foundation necessary for the Aria ecosystem to transition from experimental status to production viability.
Works cited
      1. compiled.txt
      2. Command Line Argument Parsing Libraries - hacking C++, accessed December 21, 2025, https://hackingcpp.com/cpp/libs/cmdline_args_parsing.html
      3. Which library would you recommend for parsing command line arguments? : r/cpp - Reddit, accessed December 21, 2025, https://www.reddit.com/r/cpp/comments/4zhm2n/which_library_would_you_recommend_for_parsing/
      4. CLIUtils/CLI11: CLI11 is a command line parser for C++11 and beyond that provides a rich feature set with a simple and intuitive interface. - GitHub, accessed December 21, 2025, https://github.com/CLIUtils/CLI11
      5. C++17 Command Line Parsing! | Simon Schneegans' Blog - GitHub Pages, accessed December 21, 2025, http://schneegans.github.io/tutorials/2019/08/06/commandline
      6. CLI11/examples/subcommands.cpp at main - GitHub, accessed December 21, 2025, https://github.com/CLIUtils/CLI11/blob/master/examples/subcommands.cpp
      7. external-tools / cli11 - GitLab, accessed December 21, 2025, https://code.nap.av.it.pt/external-tools/cli11/-/blob/v2.1.2/chapters/config.md
      8. DESTDIR (GNU Coding Standards), accessed December 21, 2025, https://www.gnu.org/prep/standards/html_node/DESTDIR.html