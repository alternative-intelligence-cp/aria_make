Architectural Specification and Implementation Report: AriaBuild Variable Interpolation Engine
1. Executive Summary
The AriaBuild system, internally designated as aria_make, represents a paradigm shift in build automation tailored specifically for the Aria programming language ecosystem. Unlike legacy tools such as GNU Make, which rely on imperative shell scripting and fragile whitespace sensitivity, AriaBuild adopts a "Configuration as Data" philosophy.1 A central pillar of this architecture is the Variable Interpolation Engine (Task 2), a high-priority subsystem responsible for the deterministic, recursive resolution of dynamic string values within the build configuration.1
This report provides a comprehensive architectural audit, theoretical analysis, and production-ready C++ implementation for the Interpolator class. The subsystem is designed to handle complex variable dependencies, enabling developers to define reusable paths (e.g., src: "source", obj: "&{src}/obj") and environment-dependent settings (e.g., &{ENV.HOME}) without the non-determinism associated with Turing-complete scripting languages.1
Key deliverables detailed in this document include:
1. Graph-Theoretic Resolution Model: A formal analysis of variable dependencies as a Directed Acyclic Graph (DAG), utilizing Depth-First Search (DFS) for resolution and a "Gray Set" marking algorithm for strict cycle detection.2
2. Scoping Architecture: A hierarchical scoping strategy that resolves conflicts between local target variables, global project settings, and system environment variables, ensuring predictable precedence rules.1
3. C++17 Implementation: A complete, robust implementation of the Interpolator class, featuring std::string_view for efficient tokenization, std::unordered_set for $O(1)$ cycle detection, and std::getenv integration for POSIX-compliant environment access.1
4. Verification Suite: A comprehensive unit test strategy demonstrating the system's resilience against circular dependencies, missing values, and complex nested interpolations.
The analysis confirms that the proposed implementation bridges the critical functionality gap identified in recent architectural audits 1, providing a stable foundation for the subsequent dependency graph and scheduler components.
2. Introduction: The Imperative for Deterministic Configuration
The evolution of software build systems has been characterized by a constant tension between expressiveness and determinism. Early tools like Make offered immense power through shell integration but suffered from "invisible" syntax errors due to significant whitespace and platform-specific shell quirks.1 Modern meta-build systems like CMake and Ninja attempted to resolve this by separating the build definition (CMakeLists.txt) from the execution plan (build.ninja), yet often reintroduced complexity through custom scripting languages.3
AriaBuild aims to synthesize the best attributes of these predecessors while eliminating their historical baggage. By utilizing a JSON-derivative syntax—the Aria Build Configuration (ABC) format—it ensures that build definitions are structurally rigorous, whitespace-insensitive, and easily parseable by both humans and machines.1 However, a purely declarative JSON format lacks the flexibility required for complex projects. Developers cannot afford to repeat the same output directory path fifty times in a configuration file; they require a mechanism to define a value once and reference it everywhere.
2.1 The Role of the Interpolator
The Variable Interpolation Engine serves as the dynamic heart of this static configuration structure. It transforms the "inert" JSON-like data into a "live" build graph. This transformation is not merely text substitution; it is a semantic resolution process that must adhere to strict correctness proofs.
If a build system allows variables to reference each other, it implicitly allows the creation of dependency graphs.
* Valid State: A DAG where all paths terminate in a literal value.
   * ROOT = "src", APP = "&{ROOT}/main" $\rightarrow$ src/main
* Invalid State: A cyclic graph where no resolution is possible.
   * A = "&{B}", B = "&{A}" $\rightarrow$ $\infty$
The Interpolator must detect these invalid states immediately. A build tool that hangs indefinitely due to a user configuration error is professionally unacceptable. Therefore, the architectural complexity of Task 2 is classified as "Medium" not because of the string manipulation, which is trivial, but because of the graph traversal and error reporting requirements.1
2.2 Project Dependencies and Gap Analysis
The implementation of the Interpolator relies on the Abstract Syntax Tree (AST) structures defined in Task 1 (The Parser).1 Specifically, the Parser produces a map of key-value pairs representing the raw variable definitions. The Interpolator consumes this map.
Recent gap analysis of the aria_make codebase revealed a critical deficiency: while the Lexer and AST nodes for the Aria language exist, the specific logic to parse and resolve build configuration variables was entirely absent.1 The gap analysis explicitly prioritized the creation of an Interpolator class that handles recursive resolution and environment access, noting that "the current codebase treats string literals as atomic, static tokens" without semantic processing.1 This report directly addresses Gap G03 (Interpolator Missing).
3. Theoretical Framework: Graph Theory and Scoping
Before implementation, we must establish the mathematical and logical rules governing variable resolution. This ensures the C++ implementation is grounded in sound theory rather than ad-hoc string patching.
3.1 Dependency Graph Modeling
Let $V$ be the set of all defined variables in the configuration. Each variable $v \in V$ is associated with a string expression $E(v)$.
The expression $E(v)$ is a sequence of literals and references. A reference to variable $u$ is denoted as $\&\{u\}$.
We define a directed graph $G = (V, E)$ where a directed edge $(v, u) \in E$ exists if and only if the expression $E(v)$ contains the token $\&\{u\}$.
* Resolution: The value of $v$, denoted $Val(v)$, is computed by replacing every $\&\{u\}$ in $E(v)$ with $Val(u)$.
* Base Case: If $E(v)$ contains no references, $Val(v) = E(v)$.
* Recursive Step: If $E(v) = "prefix \&\{u\} suffix"$, then $Val(v) = "prefix " + Val(u) + " suffix"$.
This recursive definition implies that resolution equates to a post-order traversal of the dependency tree rooted at $v$. However, since nodes can be shared (multiple variables referencing src), it is a DAG traversal.
3.2 Cycle Detection Theory
A cycle exists if there is a path $v_1 \to v_2 \to \dots \to v_n \to v_1$. In a recursive implementation, this manifests as infinite recursion. To prevent this, we employ a standard graph coloring algorithm during Depth-First Search (DFS).2
Nodes can be in one of three states:
1. White (Unvisited): The variable has not yet been resolved in the current context.
2. Gray (Visiting): The variable is currently in the recursion stack. We have begun resolving it but have not finished.
3. Black (Visited): The variable has been fully resolved and its value is cached.
Algorithm:
When resolve(u) is called:
1. If $u$ is Black, return cached value.
2. If $u$ is Gray, a cycle is detected ($u$ was already entered but not exited). Throw Error.
3. Mark $u$ as Gray.
4. For each referenced variable $w$ in $E(u)$:
   * Call resolve(w).
   * Substitute result into $E(u)$.
5. Mark $u$ as Black.
6. Return result.
This algorithm guarantees termination. If the graph is acyclic, it returns the value. If cyclic, it throws an error. The time complexity is $O(N + E)$ where $N$ is variables and $E$ is dependencies, ensuring the "Performance" requirement of the parser is met.1
3.3 Scoping Hierarchies
The problem statement requires "Proper scoping (local > global > environment)".1 In typical build systems like Make or CMake, scopes form a hierarchy.
1. Local Scope: Variables defined within a specific Target (e.g., a custom flags variable for a specific library).
2. Global Scope: Variables defined in the top-level variables: block.
3. Environment Scope: Variables inherited from the OS shell.
Resolution Logic:
When a token &{VAR} is encountered:
1. Check Local: Does VAR exist in the target's definition? If yes, use it.
2. Check Global: Does VAR exist in the global map? If yes, use it.
3. Check Environment: Is it prefixed with ENV.? If yes, query the OS. (Note: The prompt implies explicit ENV. prefix for environment variables, which simplifies collision handling, effectively placing them in a separate namespace 1).
Implementation Strategy:
To simplify the Interpolator class signature (which requires a single VariableMap), the caller (ConfigParser) typically performs a "Scope Merge" before passing the map to the Interpolator. Alternatively, the Interpolator can support a "Chain of Responsibility" lookup. Given the prompt's constraint ("Accept... a VariableMap"), we will implement the Interpolator to operate on a primary map (representing the merged Local+Global scope) while handling ENV. as a special intrinsic case. This aligns with the "Configuration as Data" model where the context is fully determined before processing.1
4. Architectural Design
The Interpolator is designed as a standalone semantic analysis component. It does not depend on the Lexer or Parser directly; it relies only on standard C++ containers. This loose coupling allows it to be tested in isolation and potentially reused in other parts of the Aria ecosystem (e.g., the package manager).
4.1 Class Structure
Component
	Type
	Responsibility
	Interpolator
	Class
	Main interface for variable resolution.
	VariableMap
	Type Alias
	std::map<std::string, std::string> holding the definitions.
	InterpolatorError
	Exception
	Custom exception class for reporting cycles and missing vars.
	resolve
	Method
	Public entry point. Accepts raw string, returns resolved string.
	resolve_impl
	Private Method
	Recursive helper implementing the DFS logic.
	lookup_value
	Private Method
	Handles the map lookup vs. std::getenv logic.
	cycle_tracker
	Member
	std::vector<std::string> to track the "Gray" set and reconstruct paths.
	cache
	Member
	std::unordered_map for memoization (The "Black" set).
	4.2 Error Handling Architecture
The requirement to provide "location if possible" presents a challenge: the input to resolve is a std::string, which carries no source line information.
Design Decision: The Interpolator will throw exceptions containing logic errors (e.g., "Cycle A->B->A", "Undefined variable X"). The caller (ConfigParser), which knows the current line number being parsed, will catch these exceptions and wrap them in a ParserError that adds the line/column context. This maintains separation of concerns: the Interpolator knows what went wrong, the Parser knows where it happened.1
4.3 Environment Access Safety
Accessing environment variables via std::getenv is generally thread-unsafe if setenv is called concurrently.4
* Risk: Low. AriaBuild parses configuration in the main thread before spawning worker threads.1
* Mitigation: The implementation will treat the environment as read-only. We will not use setenv or putenv.
* Requirement: The system must strictly validate ENV. lookups. If &{ENV.missing} is used, it must fail hard. Returns of nullptr from std::getenv will be converted to exceptions.1
5. Implementation: The Interpolator Subsystem
The following C++17 implementation fulfills all requirements: recursive resolution, cycle detection with path reporting, environment access, and caching.
5.1 Header File (include/config/interpolator.h)


C++




/**
* @file interpolator.h
* @brief Definition of the Variable Interpolation Engine for AriaBuild.
* 
* This component is responsible for resolving recursive variable substitutions
* in build configuration strings using the &{var} syntax.
*/

#ifndef ARIA_CONFIG_INTERPOLATOR_H
#define ARIA_CONFIG_INTERPOLATOR_H

#include <string>
#include <map>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <stdexcept>
#include <string_view>

namespace aria {
namespace config {

/**
* @class InterpolatorError
* @brief Exception thrown when variable resolution fails due to cycles, 
*        undefined variables, or syntax errors.
*/
class InterpolatorError : public std::runtime_error {
public:
   explicit InterpolatorError(const std::string& message) 
       : std::runtime_error(message) {}
};

/**
* @class Interpolator
* @brief Engine for recursive variable substitution.
* 
* Implements a Depth-First Search (DFS) resolution algorithm with:
* - Cycle detection (Gray Set tracking)
* - Memoization (Black Set caching)
* - Environment variable access (ENV. prefix)
*/
class Interpolator {
public:
   // Alias for the symbol table type. std::map is used for ordered traversal capability if needed,
   // though unordered_map would be slightly faster. std::map aligns with the prompt requirements.
   using VariableMap = std::map<std::string, std::string>;

   /**
    * @brief Constructs the Interpolator with a reference to the variable scope.
    * 
    * @param variables A read-only reference to the map containing variable definitions.
    *                  The map usually represents the merged Local + Global scope.
    */
   explicit Interpolator(const VariableMap& variables);

   /**
    * @brief Resolves all variable references in the input string.
    * 
    * Scans the string for &{...} tokens and recursively resolves them.
    * 
    * @param input The raw string containing potential &{...} tokens.
    * @return std::string The fully resolved string.
    * @throws InterpolatorError If a cycle is detected, a variable is missing, or syntax is invalid.
    */
   std::string resolve(const std::string& input);

private:
   const VariableMap& variables_;

   // Tracks the current recursion path for cycle detection.
   // Using a vector allows us to reconstruct the exact cycle path for error messages.
   // This acts as the "Gray Set" (elements present imply they are being visited).
   std::vector<std::string> recursion_stack_;
   
   // For O(1) lookup to check existence in recursion_stack_ (optimization).
   std::unordered_set<std::string> recursion_set_;

   // Cache of fully resolved variable values (The "Black Set").
   // Prevents re-resolving "src" 50 times if it's used 50 times.
   std::unordered_map<std::string, std::string> cache_;

   /**
    * @brief Internal recursive helper for resolution.
    */
   std::string resolve_impl(const std::string& input);

   /**
    * @brief Looks up a variable key and returns its RESOLVED value.
    * 
    * Handles:
    * 1. ENV. prefix checks
    * 2. Cache lookups
    * 3. Cycle checks
    * 4. Recursive calls
    * 
    * @param key The variable identifier (e.g., "src" or "ENV.PATH").
    * @return Resolved string value.
    */
   std::string resolve_var_key(const std::string& key);

   /**
    * @brief Helper to fetch environment variables safely.
    */
   std::string get_env_var(const std::string& name);

   /**
    * @brief formats the cycle path for the error message.
    * e.g., "A -> B -> C -> A"
    */
   std::string format_cycle_error(const std::string& current_key);
};

} // namespace config
} // namespace aria

#endif // ARIA_CONFIG_INTERPOLATOR_H

5.2 Implementation File (src/config/interpolator.cpp)
The implementation utilizes std::ostringstream for efficient string construction and std::string::find for parsing tokens.


C++




/**
* @file interpolator.cpp
* @brief Implementation of the Interpolator class.
*/

#include "config/interpolator.h"
#include <cstdlib>
#include <sstream>
#include <iostream>
#include <algorithm>

namespace aria {
namespace config {

Interpolator::Interpolator(const VariableMap& variables)
   : variables_(variables) {}

std::string Interpolator::resolve(const std::string& input) {
   // Clear transient recursion state. 
   // Note: We DO NOT clear the cache_, as we want to reuse resolved values 
   // across multiple resolve() calls for different strings in the same build.
   recursion_stack_.clear();
   recursion_set_.clear();
   
   return resolve_impl(input);
}

std::string Interpolator::resolve_impl(const std::string& input) {
   // Optimization: If the string has no tokens, return immediately.
   if (input.find("&{") == std::string::npos) {
       return input;
   }

   std::ostringstream result;
   size_t cursor = 0;
   
   while (cursor < input.length()) {
       // Search for the start delimiter "&{"
       size_t start_pos = input.find("&{", cursor);
       
       // If no more tokens, append the rest of the string
       if (start_pos == std::string::npos) {
           result << input.substr(cursor);
           break;
       }

       // Append the literal text before the token
       result << input.substr(cursor, start_pos - cursor);

       // Find the closing delimiter "}"
       size_t end_pos = input.find("}", start_pos);
       if (end_pos == std::string::npos) {
           throw InterpolatorError("Syntax Error: Unclosed variable substitution token starting at position " + std::to_string(start_pos));
       }

       // Extract the variable key (between &{ and })
       // Length of "&{" is 2. 
       std::string key = input.substr(start_pos + 2, end_pos - (start_pos + 2));
       
       // Validate key is not empty
       if (key.empty()) {
            throw InterpolatorError("Syntax Error: Empty variable substitution &{} at position " + std::to_string(start_pos));
       }

       // Resolve the variable recursively
       result << resolve_var_key(key);

       // Advance cursor past the closing brace
       cursor = end_pos + 1;
   }

   return result.str();
}

std::string Interpolator::resolve_var_key(const std::string& key) {
   // 1. Handle Environment Variables (ENV. prefix)
   // These are leaf nodes in our graph (no further recursion into the OS environment)
   if (key.size() > 4 && key.compare(0, 4, "ENV.") == 0) {
       return get_env_var(key.substr(4));
   }

   // 2. Check Cache (Memoization)
   // If we've already resolved this variable in this lifetime, return it.
   if (cache_.count(key)) {
       return cache_.at(key);
   }

   // 3. Cycle Detection
   // If the key is currently in the recursion stack, we have a loop.
   if (recursion_set_.count(key)) {
       throw InterpolatorError(format_cycle_error(key));
   }

   // 4. Lookup Variable Definition
   auto it = variables_.find(key);
   if (it == variables_.end()) {
       throw InterpolatorError("Undefined variable: '" + key + "'");
   }

   // 5. Recursive Resolution
   // Mark as visiting (Gray)
   recursion_stack_.push_back(key);
   recursion_set_.insert(key);

   std::string resolved_value;
   try {
       // Recursively resolve the *definition* of the variable.
       // e.g., if key="A" and value="&{B}/bin", we must resolve "&{B}/bin"
       resolved_value = resolve_impl(it->second);
   } catch (...) {
       // Clean up stack on exception to maintain consistency
       recursion_set_.erase(key);
       recursion_stack_.pop_back();
       throw;
   }

   // Unmark (move from Gray to Black)
   recursion_set_.erase(key);
   recursion_stack_.pop_back();

   // 6. Update Cache
   cache_[key] = resolved_value;

   return resolved_value;
}

std::string Interpolator::get_env_var(const std::string& name) {
   // std::getenv is safe here as we assume the environment is not modified 
   // by other threads during the configuration parsing phase.
   const char* val = std::getenv(name.c_str());
   if (val == nullptr) {
       throw InterpolatorError("Undefined Environment Variable: '" + name + "'");
   }
   return std::string(val);
}

std::string Interpolator::format_cycle_error(const std::string& current_key) {
   std::ostringstream ss;
   ss << "Cycle detected: ";
   
   // Find where the cycle started in the stack
   auto it = std::find(recursion_stack_.begin(), recursion_stack_.end(), current_key);
   
   // Print the path from the first occurrence to the end
   if (it!= recursion_stack_.end()) {
       for (; it!= recursion_stack_.end(); ++it) {
           ss << *it << " -> ";
       }
   }
   ss << current_key; // Close the loop
   return ss.str();
}

} // namespace config
} // namespace aria

5.3 Unit Testing (tests/config/test_interpolator.cpp)
Verification is critical. The following test suite covers the primary requirements: recursive logic, caching, environment access, and error reporting.


C++




#include "config/interpolator.h"
#include <cassert>
#include <iostream>
#include <map>
#include <functional>

using namespace aria::config;

// Simple test framework helper
void run_test(const std::string& name, std::function<void()> test_fn) {
   try {
       test_fn();
       std::cout << " " << name << std::endl;
   } catch (const std::exception& e) {
       std::cout << "[FAIL] " << name << ": " << e.what() << std::endl;
       std::exit(1);
   }
}

void assert_eq(const std::string& actual, const std::string& expected) {
   if (actual!= expected) {
       throw std::runtime_error("Expected '" + expected + "', got '" + actual + "'");
   }
}

void assert_throws_contain(std::function<void()> fn, const std::string& error_substr) {
   try {
       fn();
   } catch (const InterpolatorError& e) {
       std::string err = e.what();
       if (err.find(error_substr) == std::string::npos) {
            throw std::runtime_error("Error message '" + err + "' did not contain '" + error_substr + "'");
       }
       return;
   }
   throw std::runtime_error("Expected exception was not thrown");
}

int main() {
   std::cout << "Running Interpolator Tests...\n";

   // Common Setup
   std::map<std::string, std::string> vars;
   vars["src"] = "src";
   vars["build"] = "build";
   vars["base"] = "&{build}/out";
   vars["deep"] = "&{base}/bin";
   vars["recursive_part"] = "sub";
   vars["multi"] = "A-&{src}-B-&{build}-C";

   Interpolator interpolator(vars);

   // Test 1: Basic Substitution
   run_test("Simple Substitution", [&]() {
       assert_eq(interpolator.resolve("&{src}/main.aria"), "src/main.aria");
   });

   // Test 2: Nested Substitution
   // &{deep} -> &{base}/bin -> &{build}/out/bin -> build/out/bin
   run_test("Nested Substitution", [&]() {
       assert_eq(interpolator.resolve("&{deep}"), "build/out/bin");
   });

   // Test 3: Multiple Tokens
   run_test("Multiple Tokens", [&]() {
       assert_eq(interpolator.resolve("&{multi}"), "A-src-B-build-C");
   });

   // Test 4: Environment Variable
   // Note: Depends on actual environment. We'll simulate a failure case for reliability,
   // or assume PATH exists. Let's test the failure to ensure logic works.
   run_test("Missing Environment Variable", [&]() {
       assert_throws_contain([&]() {
           interpolator.resolve("&{ENV.THIS_VAR_SHOULD_NOT_EXIST_123}");
       }, "Undefined Environment Variable");
   });

   // Test 5: Cycle Detection (Direct)
   run_test("Cycle Detection (Direct)", [&]() {
       std::map<std::string, std::string> cyclic_vars;
       cyclic_vars["self"] = "&{self}";
       Interpolator cyc(cyclic_vars);
       assert_throws_contain([&]() {
           cyc.resolve("&{self}");
       }, "Cycle detected: self -> self");
   });

   // Test 6: Cycle Detection (Transitive)
   run_test("Cycle Detection (Transitive)", [&]() {
       std::map<std::string, std::string> cyclic_vars;
       cyclic_vars["A"] = "&{B}";
       cyclic_vars = "&{C}";
       cyclic_vars["C"] = "&{A}";
       Interpolator cyc(cyclic_vars);
       
       // Error should be: Cycle detected: A -> B -> C -> A
       assert_throws_contain([&]() {
           cyc.resolve("&{A}");
       }, "A -> B -> C -> A");
   });

   // Test 7: Caching
   // We can't easily inspect internals, but we can verify consistency
   run_test("Caching Consistency", [&]() {
       assert_eq(interpolator.resolve("&{deep}"), "build/out/bin");
       assert_eq(interpolator.resolve("&{deep}"), "build/out/bin");
   });

   // Test 8: Missing Variable
   run_test("Missing Variable", [&]() {
        assert_throws_contain([&]() {
           interpolator.resolve("Path: &{unknown}");
       }, "Undefined variable");
   });

   std::cout << "All Tests Passed.\n";
   return 0;
}

6. Technical Deep Dive and Analysis
The implementation of the Interpolator involves several specific technical choices driven by C++17 standards and the requirement for high performance and safety.
6.1 String Handling Strategy
The parser relies heavily on string manipulation.
* Tokenization: We deliberately avoided std::regex for tokenizing &{...}. While regex is powerful, the C++ implementation of std::regex is known to be slow to compile and execute compared to manual string scanning.3 For a simple delimiter pair, std::string::find is orders of magnitude faster and generates less binary bloat.
* String Construction: std::ostringstream was selected for building the result. In scenarios with many variable substitutions, repeated std::string::operator+= can lead to excessive reallocations. ostringstream (or std::string::reserve + append) generally offers better amortization of memory costs.3
6.2 Cycle Detection Implementation
The requirement for a "human-readable error" like A -> B -> C -> A necessitated a slight deviation from the simplest O(1) cycle detection.
* Standard approach: Use std::unordered_set<std::string> visiting. This tells you that a cycle exists but not the order.
* Our approach: We maintain both a std::vector<std::string> recursion_stack_ (to preserve order for the error message) and a std::unordered_set<std::string> recursion_set_ (for O(1) lookup).
   * Trade-off: This doubles the memory usage for the current path, but since recursion depth in build files rarely exceeds 50, the absolute cost is negligible (kilobytes), while the O(1) lookup prevents the $O(N^2)$ behavior of searching the vector at every step.2
6.3 Environment Variable Safety
The audit 1 raised concerns about std::getenv.
* Thread Safety: The standard 4 states getenv is thread-safe only if the environment is not modified. AriaBuild's architecture ensures that the interpolation phase occurs during the serial "Configuration Loading" stage, prior to the parallel "Execution" stage. Therefore, this implementation is compliant.
* Portability: std::getenv is part of the C++ standard library and is portable across Windows (MSVC), Linux (GCC/Clang), and macOS. It correctly abstracts the platform differences in environment block access.
* Undefined Behavior: Accessing the pointer returned by getenv after a subsequent call is technically unsafe in some legacy implementations, but we immediately construct a deep-copy std::string from the result (std::string(val)), mitigating lifetime issues.
6.4 Complexity Analysis
Let $L$ be the length of the input string, $V$ be the number of unique variables, and $D$ be the maximum depth of the dependency graph.
* Time Complexity: With caching (memoization), each variable is resolved exactly once. The complexity is proportional to the total size of all expanded variable definitions. $O(\sum |Val(v)|)$. Without caching, it would be exponential in the worst case (diamond dependencies). The implemented solution is optimal.
* Space Complexity: $O(V \times \text{avg\_len})$ to store the cache. This is linear with respect to the project configuration size.
7. Integration Guide
To integrate this Interpolator into the existing ConfigParser (Task 1), follow this sequence:
1. Parse Variables: The Parser processes the variables: {... } block first. It populates a std::map<std::string, std::string>.
2. Instantiate Interpolator: Create an instance of Interpolator passing this map.
3. Validate Variables: Iterate through the map and call interpolator.resolve("&{" + key + "}") for every key. This forces an early check for cycles and missing dependencies within the variable block itself.
4. Parse Targets: When parsing the targets: [... ] block:
   * For every string value (e.g., sources, output), call interpolator.resolve(raw_string).
   * Store the resolved string in the Target struct.
   * Context: If resolve throws an exception, catch it in the Parser loop. Use the Parser's current token location to throw a new ParserError that includes the filename and line number (e.g., build.aria:15: error: Cycle detected...).
8. Future Roadmap
While the current implementation satisfies the "Medium Complexity" requirements 1, future versions of AriaBuild could enhance this engine:
1. Scope Overrides: Implementing a ScopedInterpolator wrapper that allows temporarily pushing a local variable map (e.g., for target-specific variables) on top of the global map without copying it.
2. Shell Expansion: Adding syntax like &{$(shell date)} to execute shell commands, similar to Make. This was explicitly excluded from the current scope to maintain determinism but is a common feature request.1
3. Functions: Adding string manipulation functions like &{to_upper(src)} or &{join(srcs, " ")} would greatly enhance expressiveness.
9. Conclusion
The Variable Interpolation Engine presented here provides a robust, safe, and performant solution for dynamic configuration in AriaBuild. By strictly adhering to graph theory principles for cycle detection and leveraging modern C++ idioms for efficient text processing, it meets the high reliability standards required for a build tool. The code is modular, testable, and ready for immediate integration, closing a significant gap in the Aria ecosystem's roadmap.
________________
Data References:
* 1 Designing a JSON-like Build Tool.txt
* 1 task_01_parser_implementation.txt
* 1 gemini_gap_todo.txt
* 1 Gemini Analysis of Gap Todo
* 1 Prompt 2 details for Interpolator Engine
* 2 Graph Cycle Detection
* 4 std::getenv Thread Safety
* 3 C++ String Efficiency
Works cited
1. Designing a JSON-like Build Tool.txt
2. Graph Cycle Detection in C++ - GeeksforGeeks, accessed December 19, 2025, https://www.geeksforgeeks.org/cpp/graph-cycle-detection-in-cpp/
3. What is the most efficient way to build a string with many parts? - Reddit, accessed December 19, 2025, https://www.reddit.com/r/cpp/comments/1dc65b0/what_is_the_most_efficient_way_to_build_a_string/
4. std::getenv - cppreference.com, accessed December 19, 2025, http://ld2014.scusa.lsu.edu/cppreference/en/cpp/utility/program/getenv.html
5. How can getenv() be thread-safe? - c++ - Stack Overflow, accessed December 19, 2025, https://stackoverflow.com/questions/30476600/how-can-getenv-be-thread-safe