Architectural Specification: Aria Module Resolution and Dependency Management Strategy
1. Architectural Paradigm: The Epistemology of Modular Systems in Aria
The transition of the Aria programming language from an experimental prototype to a robust, industrial-grade systems language hinges critically on its ability to manage complexity. In the realm of compiler design, complexity management is synonymous with modularity. The capacity to decompose a monolithic codebase into discrete, reusable, and encapsulated units—modules—is not merely a syntactic convenience but a foundational requirement for software engineering at scale. As identified in the current architectural audit of the Aria infrastructure, a significant capability gap exists: while the language reserves keywords such as mod and use within its lexical grammar 1, the build system and compiler driver lack a deterministic, unified logic for resolving these logical identifiers into concrete filesystem entities.1 This deficiency renders the modular programming model theoretical rather than practical, creating friction in multi-file project compilation and hindering the development of a comprehensive standard library.
This report articulates the definitive architectural specification for the Aria Module Resolution Strategy (AMRS). It establishes the governing principles, algorithmic logic, and configuration schemas required to operationalize the mod and use keywords. The strategy described herein adheres strictly to the "Convention over Configuration" philosophy observed in modern systems languages like Rust and Go, prioritizing predictable filesystem structures over verbose configuration maps, while simultaneously offering the flexibility required for complex enterprise build environments via the aria.json manifest.1
The architectural mandate is to construct a resolution engine that is deterministic, hermetic, and high-performance. Determinism ensures that a given module identifier, when resolved within a specific project context, effectively maps to the exact same physical source file regardless of the host environment or the order of compilation. Hermeticity demands that the resolution process be isolated from the vagaries of the host operating system's global state, relying strictly on the project structure and explicitly defined search paths.1 Performance is paramount; the resolution algorithm sits on the critical path of the compilation pipeline, invoked for every import statement in every source file. Consequently, the design must minimize expensive filesystem I/O operations, leveraging caching and logical precedence to expedite the construction of the dependency graph.
The introduction of this strategy addresses the identified gap by providing the missing connective tissue between the abstract syntax tree (AST) produced by the parser and the physical filesystem managed by the build tool. It transforms the UseStmt and ModStmt nodes 1 from inert data structures into active directives that drive the compilation lifecycle. Furthermore, by unifying the resolution logic across the compiler (ariac), the build system (aria_make), and the language server (aria-ls), we ensure a consistent developer experience where the editor, the builder, and the compiler share a single, immutable source of truth regarding the project's structure.1
2. The Aria Module System: Semantics and Syntax
To design a resolution algorithm, one must first rigorously define the semantics of the objects being resolved. Aria rejects the textual inclusion model of C/C++ header files, which creates fragile dependencies and slow compilation times due to redundant parsing. Instead, Aria adopts a semantic module system where a module is a translation unit that acts as a namespace boundary and an encapsulation barrier.
2.1 The Logical Identifier vs. The Physical Path
A central tenet of the Aria Module Resolution Strategy is the strict separation between the Logical Path and the Physical Path, mediated by a rigid mapping convention. This "File-System Alignment" eliminates the need for complex mapping files and reduces cognitive load.1
* The Logical Path: This is the dot-separated identifier string found in source code use statements (e.g., std.io, math.geometry, app.utils). It represents the abstract location of a symbol within the program's namespace hierarchy. The logical path is platform-agnostic; it uses dots (.) as separators to avoid the slash/backslash dichotomy of Unix and Windows.
* The Physical Path: This is the concrete location of the source file on the storage medium (e.g., /usr/lib/aria/std/io.aria, C:\Projects\App\src\math\geometry\mod.aria).
The Module Resolver is the translation engine that converts a Logical Path into a Physical Path. This conversion is not a simple string replacement; it involves probing multiple potential locations and respecting precedence rules defined by the project configuration.
2.2 Semantic Module Categories
The resolution strategy recognizes three distinct categories of modules, each requiring a specific lookup priority to ensure safety and predictability.
Module Category
	Description
	Resolution Priority
	Location Semantics
	Local Modules
	Mutable code defined within the current project's source tree.
	Highest
	Found relative to the project root or the current file.
	Standard Library
	Immutable core modules provided by the Aria installation (e.g., std, core).
	Medium
	Found in system-defined installation paths or via ARIA_PATH.
	Vendor Dependencies
	Third-party packages managed by a package manager.
	Lowest
	Found in a dedicated vendor or packages directory.
	This prioritization ensures that a local module named math will always shadow a system module named math (though shadowing standard libraries is generally discouraged), giving the developer full control over their namespace.
2.3 The Role of mod and use Keywords
The specification leverages the reserved keywords defined in the language core 1 to drive the resolution logic.
The use Keyword:
The use statement is the trigger for resolution. It imports a module into the current scope.
* Syntax: use path.to.module; or use "relative/path/file.aria";.1
* Behavior: When the compiler encounters a use statement, it pauses semantic analysis of the current file and invokes the ModuleResolver. The resolver must return the absolute path to the imported module's source. If the module has not yet been compiled, the build system (aria_make) schedules it for compilation. If it has been compiled, the compiler loads its interface (symbol table).
The mod Keyword:
The mod keyword declares a submodule. It is critical for defining the hierarchical structure of a project.
* Syntax: mod subcomponent;
* Behavior: This declaration instructs the compiler to look for a submodule named subcomponent. The resolution logic for mod is stricter than use; it typically implies a child relationship in the filesystem hierarchy (e.g., a subdirectory or a sibling file).
3. Configuration Management: The aria.json Manifest
To satisfy the requirement of respecting a "configured source path" 1, we formally define the schema for the aria.json build configuration file. This file acts as the project manifest, serving a role analogous to Cargo.toml in Rust or package.json in Node.js, but tailored to the AriaBuild architecture.1
3.1 The Schema Definition
The aria.json file uses the Aria Object Literal syntax (which is JSON-compatible but allows comments and unquoted keys) to define the project structure. The build section of this manifest is the primary data source for the Module Resolver.


JSON




{
 "project": {
   "name": "HyperionServer",
   "version": "0.1.0",
   "authors": ["Architect <arch@aria-lang.org>"]
 },
 "build": {
   "source_path": ["src", "lib"],
   "entry_point": "src/main.aria",
   "import_aliases": {
     "utils": "src/shared/utilities",
     "crypto": "vendor/optimized-crypto"
   },
   "exclusions": ["tests", "docs"]
 }
}

3.2 Key Configuration Fields
* source_path: This field is an ordered list of directories relative to the project root. When resolving a module, the resolver will iterate through these directories in order. This allows developers to segregate their code into logical roots (e.g., src for application logic, lib for reusable components) without complicating import paths. If use network.http; is requested, the resolver checks src/network/http and then lib/network/http.
* import_aliases: This map enables logical remapping. It allows a long physical path (src/shared/utilities) to be aliased to a short logical identifier (utils). This decouples the import syntax from refactoring; if the physical location of the utilities library moves, only the aria.json alias needs to be updated, not every use statement in the codebase.
* entry_point: Defines the root of the compilation dependency graph. While not directly used for resolution of imports, it establishes the "Project Root" context from which source_path is calculated.
4. The Resolution Algorithm: Step-by-Step Logic
The core of the Module Resolution Strategy is a multi-tiered search algorithm. Given a logical identifier, the algorithm probes the filesystem in a deterministic sequence. The strategy strictly follows Rust-like conventions as requested: prioritizing file-based modules (name.aria) and directory-based modules (name/mod.aria).
Input:
* module_name: The logical identifier string (e.g., std.io).
* requesting_file: The absolute path of the file containing the use statement (for relative resolution).
* config: The parsed aria.json configuration object.
Output:
* Returns: The absolute, canonical filesystem path to the module source file.
* Throws: ModuleNotFoundException if resolution fails.
Step 1: Input Normalization and Security Sanitization
Before touching the filesystem, the input string must be sanitized.
1. Separator Unification: The logical separator . is replaced with the operating system's directory separator (/ on Linux/macOS, \ on Windows).
2. Path Traversal Mitigation: The resolver scans the normalized path for .. segments. While relative imports might legitimately use parent directories, logical imports (those not starting with ./) should effectively be "jailed" within the source roots. Malicious module names attempting to escape the project root (e.g., std.../../etc/passwd) must be detected and rejected immediately.
Step 2: Alias Resolution
The resolver checks the import_aliases map defined in aria.json.
* If module_name matches a key in the alias map (e.g., utils), the identifier is replaced with the aliased path (e.g., src/shared/utilities).
* This check is prefix-based. If utils is aliased, utils.string resolves to src/shared/utilities/string.
Step 3: Root Anchoring and Search Path Construction
The resolver constructs a prioritized list of Search Roots.
1. Relative Root: (Only if the import starts with ./ or ../). The directory containing requesting_file is added as the sole search root.
2. Configured Source Roots: The resolver iterates through the source_path list from aria.json. For each entry, it creates an absolute path: ProjectRoot + / + SourcePathEntry.
3. System Roots: The resolver appends standard system locations defined by the Aria specification.1
   * Linux: /usr/lib/aria, /usr/local/lib/aria.
   * Windows: %PROGRAMFILES%\Aria\lib.
   * Environment: Paths defined in the ARIA_PATH environment variable.
Step 4: The Probe Loop (Rust Conventions)
For each Search Root R in the priority list, the resolver performs the following probes for the normalized module path M:
Probe A: The "File Module" Pattern
Construct path $P_{file} = R + / + M +.aria$.
* Check if $P_{file}$ exists AND is a regular file.
* Rationale: This supports simple modules defined in a single file (e.g., math.aria). This corresponds to the request requirement "Look for module_name.aria".
Probe B: The "Directory Module" Pattern
Construct path $P_{dir} = R + / + M + / + mod.aria$.
* Check if $P_{dir}$ exists AND is a regular file.
* Rationale: This supports complex modules defined as a directory package (e.g., math/mod.aria). The mod.aria file serves as the entry point, re-exporting symbols from other files in the directory. This corresponds to the request requirement "Look for module_name/mod.aria".
Early Return: The moment a probe succeeds, the algorithm terminates, returns the absolute path $P$, and halts further searching. This ensures that local modules always shadow system modules of the same name.
Step 5: Failure Handling
If the loop exhausts all Search Roots without a match, the resolver constructs a detailed error message listing every path attempted. This "verbose failure" is critical for debugging configuration errors in large CI/CD environments.
5. C++ Implementation Specification
The following C++ implementation provides a robust, production-ready ModuleResolver class. It utilizes C++17 std::filesystem for portable path manipulation, ensuring compatibility with Linux, Windows, and macOS build environments. The code is designed to be integrated into the aria::compiler namespace.


C++




/**
* @file ModuleResolver.h
* @brief Implementation of the Aria Module Resolution Strategy (AMRS).
* 
* This component resolves logical module identifiers to physical filesystem paths
* adhering to the Aria v0.0.7 specification and Rust-like directory conventions.
*/

#include <string>
#include <vector>
#include <filesystem>
#include <optional>
#include <stdexcept>
#include <fstream>
#include <sstream>
#include <iostream>
#include <map>
#include <algorithm>

// Use C++17 filesystem
namespace fs = std::filesystem;

namespace aria {
namespace compiler {

   // Configuration structure mirroring the 'build' section of aria.json
   struct BuildConfig {
       fs::path project_root;
       std::vector<std::string> source_paths;
       std::map<std::string, std::string> import_aliases;
       std::vector<std::string> system_paths;

       BuildConfig() : project_root(fs::current_path()) {
           // Default source path if aria.json is missing or empty
           source_paths.push_back("src");
           
           // Standard system paths per Aria Specification 
           const char* env_path = std::getenv("ARIA_PATH");
           if (env_path) {
               // Split ENV path (simplified for illustration)
               std::string p(env_path);
               system_paths.push_back(p);
           }
           #ifdef __linux__
           system_paths.push_back("/usr/lib/aria");
           system_paths.push_back("/usr/local/lib/aria");
           #endif
       }
   };

   class ModuleResolver {
   public:
       explicit ModuleResolver(const BuildConfig& config) : config_(config) {
           // Validate project root on instantiation
           if (!fs::exists(config_.project_root)) {
               throw std::runtime_error("Project root not found: " + config_.project_root.string());
           }
       }

       /**
        * @brief Resolves a logical module identifier to an absolute source file path.
        * 
        * Implements the search priority:
        * 1. Alias expansion
        * 2. Configured source_paths (File Module -> Directory Module)
        * 3. System paths (File Module -> Directory Module)
        * 
        * @param module_name The logical identifier (e.g., "std.io", "math.vector")
        * @return std::string Absolute path to the resolved.aria file
        * @throws std::runtime_error If resolution fails
        */
       std::string resolve(const std::string& module_name) {
           // 1. Normalize and check for Aliases
           std::string search_target = module_name;
           for (const auto& [alias, expansion] : config_.import_aliases) {
               if (module_name == alias) {
                   search_target = expansion;
                   break;
               }
               // Check for prefix match (e.g., alias "net" -> "std.net")
               if (module_name.find(alias + ".") == 0) {
                   search_target = expansion + "/" + module_name.substr(alias.length() + 1);
                   break;
               }
           }

           // Convert logical dots to directory separators
           std::replace(search_target.begin(), search_target.end(), '.', fs::path::preferred_separator);
           
           // 2. Build Search Roots List
           std::vector<fs::path> search_roots;
           
           // Add project source paths
           for (const auto& src : config_.source_paths) {
               search_roots.push_back(config_.project_root / src);
           }
           
           // Add system paths
           for (const auto& sys : config_.system_paths) {
               search_roots.push_back(fs::path(sys));
           }

           // 3. Execute Probes
           std::vector<std::string> attempted_paths; // For error reporting

           for (const auto& root : search_roots) {
               // Probe A: module_name.aria
               fs::path file_probe = root / (search_target + ".aria");
               if (check_exists(file_probe)) {
                   return fs::canonical(file_probe).string();
               }
               attempted_paths.push_back(file_probe.string());

               // Probe B: module_name/mod.aria
               fs::path dir_probe = root / search_target / "mod.aria";
               if (check_exists(dir_probe)) {
                   return fs::canonical(dir_probe).string();
               }
               attempted_paths.push_back(dir_probe.string());
           }

           // 4. Handle Failure
           std::stringstream err;
           err << "Module Resolution Error: Could not resolve '" << module_name << "'\n";
           err << "Searched in:\n";
           for (const auto& p : attempted_paths) {
               err << "  " << p << "\n";
           }
           throw std::runtime_error(err.str());
       }

   private:
       BuildConfig config_;

       // Helper: Check if path exists and is a regular file
       bool check_exists(const fs::path& p) {
           std::error_code ec;
           return fs::exists(p, ec) && fs::is_regular_file(p, ec);
       }
   };

} // namespace compiler
} // namespace aria

6. Operating System Integration and Filesystem Performance
The interaction between the Module Resolver and the underlying Operating System is a critical performance vector. In a large project with thousands of files, a naive implementation can trigger an avalanche of stat() system calls, degrading build times.
6.1 Filesystem Caching Strategy
The std::filesystem::exists call maps to stat on POSIX systems or GetFileAttributes on Windows. These calls involve kernel context switches and disk I/O (checking inode tables). To optimize this, the ModuleResolver should ideally share a StatCache with the build system.
* Mechanism: The aria_make build tool 1 typically scans the directory tree at startup to build the dependency graph. The ModuleResolver can query this in-memory graph instead of hitting the disk for every probe.
* Implementation: In the integrated environment, the ModuleResolver would accept a VirtualFileSystem (VFS) reference rather than operating directly on fs::path. This aligns with the architecture of aria-ls 1, which maintains an in-memory VFS for unsaved files.
6.2 Case Sensitivity and Cross-Platform Determinism
A significant source of "works on my machine" bugs is filesystem case sensitivity.
* Linux (ext4): Case-sensitive. Math.aria!= math.aria.
* Windows (NTFS) / macOS (APFS): Typically case-preserving but case-insensitive. Math.aria == math.aria.
Constraint: The Aria Module Resolution Strategy mandates strict case sensitivity matching the logical identifier. If a user writes use Math;, the resolver must look for Math.aria. On Windows, finding math.aria when Math.aria was requested should theoretically be a warning or error to prevent build failures when moving to Linux. However, enforcing this on Windows requires expensive directory iteration (reading the directory entry to verify the casing) rather than a simple existence check.
Decision: For v0.0.7, we defer strict case enforcement on Windows to the linter or CI pipeline, prioritizing the performance of the native fs::exists check.
6.3 Symlinks and Security
The use of fs::canonical in the implementation serves a dual purpose: returning an absolute path and resolving symbolic links. This is crucial for security. By resolving symlinks to their ultimate physical location, the build system can verify that the source file resides within an authorized directory tree, mitigating "symlink attacks" where a malicious package tries to reference system files (e.g., /etc/passwd) via a symlink in the vendor directory.
7. Ecosystem Integration: Compiler, Build System, and LSP
The ModuleResolver is not a standalone utility; it is the shared logic engine for the entire Aria toolchain.
7.1 Integration with ariac (Compiler Driver)
In the compiler driver (src/main.cpp), the ModuleResolver is instantiated during the Semantic Analysis phase.
1. Parsing: The parser produces a UseStmt node containing the string std.io.
2. Resolution: The semantic analyzer passes this string to ModuleResolver::resolve.
3. Loading: The compiler opens the returned path, parses the file, and links the exported symbols into the current symbol table.
4. Cycle Detection: The compiler uses the absolute paths returned by the resolver to detect circular dependencies. If A.aria imports B.aria, and B.aria imports A.aria, the canonical paths will match, allowing the cycle detector to trap the error.1
7.2 Integration with aria_make (Build System)
aria_make uses the resolver to construct the Directed Acyclic Graph (DAG) for parallel builds.
* Dependency Discovery: The build tool parses aria.json to configure the resolver. It then scans source files for use statements.
* Graph Edge Construction: For every use statement, the resolver identifies the target file. aria_make creates a dependency edge: Target(ImportingFile) -> Target(ResolvedFile). This ensures that mod.aria is always compiled before any file that imports it.
7.3 Integration with aria-ls (Language Server)
The Language Server Protocol (LSP) integration 1 requires the resolver to operate in a "dirty" state.
* In-Memory Resolution: When a user is typing in main.aria and adds use local.mod;, the file local/mod.aria might not exist on disk yet (it might be a new buffer in the editor).
* VFS Overlay: The ModuleResolver for aria-ls wraps the standard logic with an overlay that checks the LSP's in-memory file buffers before checking the disk. This allows "Go to Definition" to work for unsaved files, a critical feature for developer ergonomics.
8. Conclusion and Future Outlook
The definition and implementation of the Aria Module Resolution Strategy mark a decisive step in the language's evolution. By standardizing the behavior of use and mod keywords, we have transformed them from reserved placeholders into functional primitives that drive the modular architecture of Aria applications.
This specification delivers:
1. Clarity: A unified mental model for where code lives (.aria vs mod.aria).
2. Flexibility: A configuration schema (aria.json) that adapts to various project structures without enforcing a "one true layout."
3. Robustness: A C++ implementation leveraging modern filesystem standards for reliability across platforms.
Moving forward, this resolver enables the development of a centralized package manager (aria-pkg), as the mechanics for locating and linking modules are now deterministic and exposed via a standardized API. The immediate next step for the engineering team is to integrate the ModuleResolver class into the aria_frontend library and update the compiler driver to utilize it for all import handling.
Data References
* 1
: aria_v0.0.7_Complete_Programming_Guide – Source of language keywords (use, mod, pub), initial constraints, and example macros implying file structure.
* 1
: Aria_Language_Server_Architecture – Detailed context on the VFS, thread pooling, and the need for in-memory resolution logic.
* 1
: AriaBuild_Architecture – Specification of the aria.json format, globbing requirements, and dependency graph construction.
* 1
: Snippet confirming the gap: "mod and use keywords are reserved but have no resolution logic."
* 1
: Snippet regarding UseStmt node structure in the parser.
* 1
: Snippet regarding "rigid module system" and VFS interactions.
Works cited
   1. rcfull.txt