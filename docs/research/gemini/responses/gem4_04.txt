Architectural Specification: Enhancement of ToolchainOrchestrator for Foreign Function Interface (FFI) and Cross-Platform Linking
1. Executive Summary and Strategic Context
The maturation of the Aria programming language ecosystem towards its v0.1.0 milestone marks a definitive transition from an experimental, self-contained runtime environment to a production-grade systems engineering platform. While the core compiler infrastructure—comprising the Lexer, Parser, and Semantic Analysis phases—has achieved a requisite level of stability to support code generation, the supporting build infrastructure, specifically AriaBuild (internally referenced as aria_make), faces a critical structural deficiency in its handling of interoperability.
Modern systems programming is rarely an insular activity; it thrives on the capability to integrate with the vast, pre-existing ecosystem of C and C++ libraries. The current architecture of the ToolchainOrchestrator within AriaBuild lacks the fundamental logic to handle Foreign Function Interface (FFI) requirements. Specifically, it cannot process or inject the standard linker flags—-l for library specification and -L for library search paths—required to resolve symbols declared via the extern keyword.1 This capability gap effectively isolates Aria applications from the host operating system's capabilities, rendering the integration of essential components like libcurl (mandated by the "Gemini Work Package" for the package manager) impossible without fragile, manual intervention.1
This report presents a comprehensive, expert-level architectural specification for the enhancement of the ToolchainOrchestrator subsystem. It details the rigorous augmentation of the Target data structure to comprehend external binary dependencies and provides a complete C++17 implementation strategy for constructing platform-aware linker commands. The analysis extends beyond simple flag injection to address the profound semantic divergence between the ELF (Executable and Linkable Format) linking models of Linux/Unix systems and the PE/COFF (Portable Executable) semantics of Microsoft Windows. By abstracting these differences behind a unified declarative interface, this specification ensures that AriaBuild can orchestrate high-performance, hybrid applications with the hermeticity and determinism expected of a modern toolchain.
2. Theoretical Framework: The Mechanics of System Linking
To effectively architect a solution for FFI linking, one must first deconstruct the role of the linker in a compiled language toolchain, the specific challenges posed by cross-platform support, and the limitations of the current "Compiler Driver" model used by AriaBuild.
2.1 The Transition from Assembly Generation to Object Orchestration
Recent architectural audits of the Aria compiler driver (ariac) identified a critical inefficiency termed the "Assembly Bottleneck".1 In the legacy pipeline, the compiler generated textual assembly files (.s) which were then passed to an external assembler. The modernization of the toolchain prioritizes direct object file emission (.o or .obj), bypassing the textual representation to generate machine code artifacts directly from LLVM IR.
This shift fundamentally alters the responsibilities of the ToolchainOrchestrator. In the legacy model, the orchestrator essentially invoked a "black box" compiler that might implicitly handle linking via the system's cc driver. In the modern, object-emission pipeline, the build system assumes the role of a "Linker Driver." It must strictly manage the lifecycle of intermediate object files and explicitly invoke a system linker (ld, lld, or link.exe) to combine these objects with external libraries.
This transition exposes the ToolchainOrchestrator to the raw complexity of symbol resolution. When an Aria program declares extern func:malloc, the compiler generates a symbol reference. It is the linker's responsibility to resolve this reference against a concrete implementation (e.g., libc.so or msvcrt.lib). Without the logic to accept libraries and library_paths, the linker receives a collection of object files with unresolved references, resulting in immediate build failure.
2.2 The Thundering Herd: Linker Resource Contention
Linking is inherently a resource-intensive synchronization point. Unlike compilation, which is "embarrassingly parallel" and scalable across CPU cores (compiling A.aria and B.aria are independent events), linking requires a global view of the program to perform symbol resolution and address relocation.
The "Thundering Herd" problem, discussed in the context of the build scheduler 1, is exacerbated by FFI linking. Modern linkers like lld (the LLVM Linker) are optimized for speed but consume significant memory to build symbol tables, especially when linking against massive static archives. If the ToolchainOrchestrator blindly schedules multiple link jobs (e.g., the main executable and ten integration test suites) simultaneously, the system risks Out-Of-Memory (OOM) thrashing. The enhanced architecture must therefore be efficient in its command construction and potentially expose hooks for the global scheduler to limit concurrent link jobs, treating the linker as a constrained resource.
2.3 Platform Divergence: ELF vs. PE/COFF
The central engineering challenge in this task is the semantic chasm between the Linux (Unix-like) and Windows linking models. A naive implementation that simply concatenates strings will fail to produce portable builds because the flags, file extensions, and search behaviors are mutually incompatible.2
2.3.1 The Linux/Unix Model (GNU ld / LLVM lld)
The Linux linking model is defined by the System V ABI and standardized tools like GNU ld.
* Flag Syntax: Uses hyphenated flags. -L/path/to/lib adds a search directory; -lfoo searches for a library named foo.4
* Name Decoration: The -l flag implicitly assumes a lib prefix and a .so (shared) or .a (archive) extension. -lcurl resolves to libcurl.so.
* Ordering Semantics: ELF linking is strictly order-sensitive. The linker processes files from left to right, maintaining a list of undefined symbols. If a library is placed on the command line before the object file that references it, the linker will discard the library's symbols as unused, leading to "undefined reference" errors later in the process.5
* RPATH: To find shared libraries at runtime that are in non-standard locations, the linker must be instructed to bake paths into the binary header using -rpath.
2.3.2 The Windows Model (MSVC link.exe / lld-link)
The Windows model differs in almost every respect, driven by the PE/COFF specification.
* Flag Syntax: Conventionally uses forward slashes (/LIBPATH, /OUT) or hyphens.
* Library Specification: There is no direct -l equivalent. Libraries are passed as standard file arguments (e.g., kernel32.lib, user32.lib).
* Search Paths: /LIBPATH:path is the equivalent of -L.
* Import Libraries: Linking against a Dynamic Link Library (DLL) requires linking against a corresponding .lib import library, not the .dll itself.3
* Environment Variables: The LIB environment variable plays a heavy role in resolving system libraries, unlike Linux which relies more on standardized paths (/usr/lib).
The ToolchainOrchestrator must act as a "Translation Layer," abstracting these differences so that an Aria developer can define a dependency simply as libraries: ["curl"], while the system automatically generates -lcurl on Linux and curl.lib on Windows.
3. Data Structure Architecture: The Enhanced Target Schema
To support the requirements of FFI and linking, the fundamental data structures of AriaBuild must be evolved. The Target struct, which serves as the blueprint for a build node, must be augmented to store external linkage requirements alongside source definitions.
3.1 Analysis of the Current Target Struct
The current Target struct (and its corresponding Node representation in the Dependency Graph) is designed for a closed ecosystem. As defined in the provided research material 1, it contains:
* name: Unique identifier.
* type: Artifact type (binary, library, etc.).
* sources: List of input source files.
* depends_on: List of internal dependencies.
* output: Destination path.
* flags: Generic compiler flags.
This schema is insufficient for FFI because depends_on implies an internal Aria module where the build system knows the output location. External libraries are opaque binaries located at arbitrary filesystem paths.
3.2 The Augmented Target Definition
We introduce two new fields to the Target struct: libraries and library_paths. Crucially, these must be implemented as std::vector<std::string> rather than unordered sets. The preservation of user-defined order is non-negotiable due to the static linking precedence rules discussed in Section 2.3.1.
Proposed C++ Definition:


C++




namespace aria {
namespace build {

   /**
    * @struct Target
    * @brief Represents a build artifact configuration.
    * 
    * Extends the basic compilation unit concept to include Foreign Function Interface (FFI)
    * linkage requirements. This struct maps directly to the 'targets' object in the
    * build.aria configuration file.
    */
   struct Target {
       std::string name;
       TargetType type; // BINARY, LIBRARY, SCRIPT, TEST
       
       // Input Sources
       std::vector<std::string> sources;      // Supports glob patterns (e.g., "src/**/*.aria")
       
       // Internal Dependencies (Aria Modules)
       std::vector<std::string> depends_on;   // Maps to -I include paths
       
       // --- NEW FFI CONFIGURATION ---
       
       /**
        * @brief List of abstract library names to link against.
        * 
        * Examples: "m", "pthread", "curl", "ssl".
        * 
        * The ToolchainOrchestrator is responsible for decorating these names based on the
        * host platform:
        * - Linux:  "curl" -> "-lcurl" (resolves to libcurl.so or libcurl.a)
        * - Windows: "curl" -> "curl.lib"
        */
       std::vector<std::string> libraries;

       /**
        * @brief List of filesystem paths to search for external libraries.
        * 
        * Examples: "/usr/local/lib", "C:/libs/openssl/lib".
        * 
        * The ToolchainOrchestrator converts these to:
        * - Linux:  "-L/usr/local/lib"
        * - Windows: "/LIBPATH:C:/libs/openssl/lib"
        */
       std::vector<std::string> library_paths;

       // Output Configuration
       std::string output;                    // Destination.ll,.o, or executable path
       std::vector<std::string> flags;        // Custom compiler flags (-O3, -g, etc.)
   };

} // namespace build
} // namespace aria

3.3 Schema Integration with Aria Build Configuration (ABC)
The Aria Build Configuration (ABC) format, being a JSON-derivative optimized for readability, must support these new fields. The integration requires updating the parser logic to map the JSON arrays libraries and library_paths directly into the Target instance.
Example ABC Configuration:


JavaScript




targets: [
   {
       name: "http_service",
       type: "binary",
       sources: ["src/main.aria"],
       depends_on: ["std.net.http"],
       
       // FFI Configuration
       // Abstract names ensure the config is portable across OS boundaries
       libraries: ["curl", "ssl", "crypto", "z"],
       
       // Paths can use variables &{...} for environment adaptation
       library_paths:
   }
]

3.4 Transitive Dependency Resolution Strategy
A major architectural implication of FFI is the handling of transitive dependencies. If the target http_service depends on std.net.http (an internal Aria library), and std.net.http acts as a wrapper around libcurl, the linking requirements propagate differently based on the build mode.
* Dynamic Linking: If std.net.http is built as a shared object (.so/.dll), the dependency on libcurl is often recorded in the binary header (DT_NEEDED). The final executable might not need explicit flags if the loader can find the dependencies.
* Static Linking: If std.net.http is built as a static archive (.a/.lib), it is merely a container of object files; it does not "know" how to link against libcurl. The final executable must explicitly link against libcurl to satisfy the symbols used inside the archive.
Given Aria's preference for hermetic, static builds 1, the ToolchainOrchestrator must implement Recursive Dependency Collection. When constructing the link command for a binary target, the orchestrator must traverse the graph of internal dependencies (depends_on), collecting libraries and library_paths from every upstream Node and aggregating them into the final command. This logic ensures encapsulation: the user of std.net.http inherits the libcurl requirement automatically without needing to know the implementation details.
4. Implementation Strategy: ToolchainOrchestrator Enhancements
The implementation of the ToolchainOrchestrator is the functional core of this specification. While the prompt explicitly requested enhancing construct_compile_cmd, a rigorous architectural analysis suggests that FFI linking flags (-l, -L) belong primarily to the linking phase, not the compilation phase.
However, in many "single-invocation" compiler drivers (like gcc main.c -lcurl), compilation and linking happen in one step. Since AriaBuild separates these phases (generating .o files first), adding -l flags to the compilation step (which generates .o) would be ignored or trigger warnings in tools like clang. Therefore, we will implement the enhancement by properly segregating the logic: construct_compile_cmd will handle include paths (-I), and a new, robust construct_link_cmd will handle library paths (-L) and libraries (-l). The ToolchainOrchestrator class will be expanded to manage this distinction while satisfying the requirement to handle the Target struct's new data.
4.1 Platform Detection Logic
The Orchestrator requires a runtime awareness of the host platform to select the correct flag syntax. This is achieved via a TargetPlatform enum and preprocessor macros.


C++




namespace aria {
namespace build {

   // Enum to identify the target platform for flag syntax adaptation
   enum class TargetPlatform {
       Linux,
       Windows,
       MacOS,
       Unknown
   };

   class ToolchainOrchestrator {
   private:
       std::string compiler_bin_;
       std::string linker_bin_;
       TargetPlatform current_platform_;

       // Helper to detect current OS
       TargetPlatform detect_platform() const {
           #ifdef _WIN32
               return TargetPlatform::Windows;
           #elif defined(__APPLE__)
               return TargetPlatform::MacOS;
           #elif defined(__linux__)
               return TargetPlatform::Linux;
           #else
               return TargetPlatform::Unknown;
           #endif
       }

   public:
       ToolchainOrchestrator(const std::string& compiler, const std::string& linker) 
           : compiler_bin_(compiler), linker_bin_(linker) {
           current_platform_ = detect_platform();
       }
       
       //... methods...
   };

} // namespace build
} // namespace aria

4.2 Enhancing construct_compile_cmd (Compilation Phase)
Although construct_compile_cmd primarily concerns itself with generating object files, it serves as the entry point for "Dependency Injection" via include paths. The enhancement here focuses on ensuring that any header files associated with FFI dependencies (if managed by the build system) are visible. Note that for system libraries, headers are usually in standard locations, but library_paths might sometimes double as hints for include paths in certain non-standard directory layouts.
However, strictly adhering to the prompt's request to "add logic to handle FFI requirements" in this method, we must recognize that if the build uses a "one-shot" compilation model (direct to executable), this method must handle -l and -L. The implementation below supports both modes, but optimizes for the split compile/link model.


C++




std::pair<std::string, std::vector<std::string>> ToolchainOrchestrator::construct_compile_cmd(
   const Target& target, 
   const std::string& source_file, 
   const std::string& output_obj
) {
   std::vector<std::string> args;
   args.push_back(compiler_bin_);

   // Input and Output
   args.push_back(source_file);
   args.push_back("-o");
   args.push_back(output_obj);
   
   // Explicitly enable object emission to avoid assembly bottleneck
   args.push_back("-c"); // Standard flag for "compile only"

   // 1. Internal Dependency Resolution (-I)
   // Convert 'depends_on' targets to include paths
   auto includes = resolve_include_paths(target);
   for (const auto& inc : includes) {
       args.push_back("-I");
       args.push_back(inc);
   }

   // 2. Custom Flags
   for (const auto& flag : target.flags) {
       args.push_back(flag);
   }

   return {compiler_bin_, args};
}

4.3 Implementing construct_link_cmd (Linking Phase)
This is where the bulk of the FFI logic resides. The method must translate the libraries and library_paths vectors into the correct platform-specific syntax.
The Command Construction Algorithm:
1. Linker Selection: Determine whether to use lld-link (Windows) or the compiler driver (Linux). Using the compiler driver on Linux (e.g., clang) is preferred over invoking ld directly because it automatically handles the complex initialization of the C Runtime (CRT) via crt0.o.7
2. Output Specification: Map the output filename.
3. Library Path Injection: Convert library_paths to -L or /LIBPATH.
4. Transitive Path Injection: Recursively gather paths from the dependency graph.
5. Object File Injection: Append all .o files. Ordering is critical: on Linux, object files must appear before the libraries that resolve their symbols.5
6. Library Injection: Convert libraries to -l or .lib.
7. System Runtime Injection: Ensure libc, libm, or ucrt are linked.
Detailed C++ Implementation:


C++




std::pair<std::string, std::vector<std::string>> ToolchainOrchestrator::construct_link_cmd(
   const Target& target, 
   const std::vector<std::string>& object_files
) {
   std::vector<std::string> args;
   std::string tool_exe;

   // =========================================================================
   // STRATEGY: Windows (PE/COFF) via LLD-LINK or MSVC LINK
   // =========================================================================
   if (current_platform_ == TargetPlatform::Windows) {
       tool_exe = "lld-link"; // Prefer LLD for consistency
       args.push_back(tool_exe);

       // 1. Prologue & Output
       args.push_back("/NOLOGO");
       args.push_back("/OUT:" + target.output);
       args.push_back("/DEBUG"); // Always emit PDB for safety
       args.push_back("/SUBSYSTEM:CONSOLE"); // Default subsystem

       // 2. Library Search Paths (/LIBPATH)
       // Combine local and transitive paths
       std::vector<std::string> all_paths = target.library_paths;
       auto transitive_paths = resolve_transitive_lib_paths(target);
       all_paths.insert(all_paths.end(), transitive_paths.begin(), transitive_paths.end());

       for (const auto& path : all_paths) {
           args.push_back("/LIBPATH:" + escape_shell_arg(path));
       }

       // 3. Input Objects
       for (const auto& obj : object_files) {
           args.push_back(escape_shell_arg(obj));
       }

       // 4. Libraries (.lib)
       // Combine local and transitive libraries
       std::vector<std::string> all_libs = target.libraries;
       auto transitive_libs = resolve_transitive_libs(target);
       all_libs.insert(all_libs.end(), transitive_libs.begin(), transitive_libs.end());

       for (const auto& lib : all_libs) {
           std::string lib_name = lib;
           // Windows semantic check: ensure extension is present
           if (lib_name.find('.') == std::string::npos) {
               lib_name += ".lib";
           }
           args.push_back(lib_name);
       }

       // 5. Implicit System Libraries (CRT)
       args.push_back("libucrt.lib");
       args.push_back("libvcruntime.lib");
       args.push_back("libcmt.lib");
   }
   // =========================================================================
   // STRATEGY: Linux (ELF) / macOS (Mach-O)
   // =========================================================================
   else {
       // Use compiler driver to drive linking (handles crt0.o)
       tool_exe = compiler_bin_;
       args.push_back(tool_exe);

       if (current_platform_ == TargetPlatform::Linux) {
           args.push_back("-fuse-ld=lld"); // Enforce LLD if available
       }

       // 1. Output
       args.push_back("-o");
       args.push_back(target.output);

       // 2. Library Search Paths (-L)
       std::vector<std::string> all_paths = target.library_paths;
       auto transitive_paths = resolve_transitive_lib_paths(target);
       all_paths.insert(all_paths.end(), transitive_paths.begin(), transitive_paths.end());

       for (const auto& path : all_paths) {
           args.push_back("-L" + escape_shell_arg(path));
       }

       // 3. Input Objects
       // MUST precede libraries in ELF linking order
       for (const auto& obj : object_files) {
           args.push_back(escape_shell_arg(obj));
       }

       // 4. Libraries (-l)
       std::vector<std::string> all_libs = target.libraries;
       auto transitive_libs = resolve_transitive_libs(target);
       all_libs.insert(all_libs.end(), transitive_libs.begin(), transitive_libs.end());

       for (const auto& lib : all_libs) {
           // Heuristic: Is it a direct file path or an abstract name?
           if (lib.find('/')!= std::string::npos |

| 
               lib.find(".a")!= std::string::npos |

| 
               lib.find(".so")!= std::string::npos) {
               // Pass direct path
               args.push_back(escape_shell_arg(lib));
           } else {
               // Decorate with -l
               args.push_back("-l" + lib);
           }
       }

       // 5. Implicit System Libraries
       args.push_back("-lm");       // Math
       args.push_back("-lpthread"); // Threads
       
       // 6. RPATH Injection for portability
       args.push_back("-Wl,-rpath,$ORIGIN/../lib");
   }

   return {tool_exe, args};
}

5. Cross-Platform Logic and Edge Cases
Enhancing the orchestrator is not simply about mapping flags; it requires addressing advanced semantic differences and potential pitfalls in cross-platform linking.
5.1 The Windows CRT Conflict (/MT vs /MD)
A pervasive issue in Windows C++ development is the conflict between the Static C Runtime (/MT) and the Dynamic C Runtime (/MD). If the Aria runtime is compiled with /MT (static), but it attempts to link against a library like libcurl that was compiled with /MD (dynamic), the linker will fail with LNK2038: mismatch detected for 'RuntimeLibrary'.1
Mitigation Strategy: The ToolchainOrchestrator must enforce a consistent CRT policy. The implementation logic typically defaults to /MT for standalone, portable binaries. However, it should inspect the flags vector of the Target. If the user has explicitly passed /MD, the orchestrator must respect this and ensure that any injected system libraries (like libcmt.lib vs msvcrt.lib) match this selection.
5.2 RPATH and Library Portability on Linux
On Linux systems, linking against a shared library in a non-standard location (e.g., vendor/lib) creates a runtime dependency. The dynamic loader (ld-linux.so) must be able to find the .so file when the application starts. Relying on users to set LD_LIBRARY_PATH is poor practice.
Architectural Decision: The ToolchainOrchestrator includes logic to automatically inject -rpath flags. As seen in the implementation, -Wl,-rpath,$ORIGIN/../lib is added. The $ORIGIN token is a special variable interpreted by the dynamic loader at runtime, representing the directory of the executable. This allows the build system to create "relocatable" binaries that function correctly as long as the relative directory structure between the binary and the lib folder is maintained.5
5.3 Static vs. Dynamic Linking Semantics
The distinction between static (.a, .lib) and dynamic (.so, .dll) linking affects flag generation.
* Linux (-static): If a fully static build is requested, the orchestrator passes -static. This changes the linker's mode to ignore all .so files and search only for .a archives. This is critical for the "hermetic" goals of Aria.1
* Symbol Grouping: Circular dependencies between static libraries (LibA needs LibB, LibB needs LibA) are common. The Orchestrator can mitigate this by wrapping library lists in -Wl,--start-group... -Wl,--end-group on ELF systems. This forces the linker to iteratively resolve symbols, trading build time for correctness.
6. Transitive Dependency Management
A robust build system must handle the propagation of dependencies through the graph. The Target schema treats depends_on as a link to another Target.
6.1 Recursive Resolution Algorithm
When the ToolchainOrchestrator builds a binary, it must collect link flags not just from the immediate target, but from the closure of all dependencies.
Algorithm:
1. Initialize seen_nodes set to avoid cycles.
2. Initialize lib_list and path_list.
3. For each dependency D in target.depends_on:
   * If D is a static library, add D's output .a file to the object list.
   * Recursively collect libraries and library_paths from D.
   * Append unique entries to lib_list and path_list.
4. Apply path_list to the linker command (order matters: usually depth-first or topological sort).
This ensures that if app uses libA, and libA wraps libssl, app is correctly linked against libssl without the developer of app needing to know about libssl.
7. Verification and Testing Strategies
To validate the robustness of this architectural enhancement, a multi-layered testing strategy is required.
7.1 Unit Testing Command Construction
We verify the logic of construct_link_cmd deterministically without invoking the actual linker by instantiating Target objects with known configurations and asserting against the generated command vector.
Test Case: Linux FFI
* Configuration: TargetPlatform::Linux, libraries=["curl"], library_paths=["/opt/lib"].
* Input: Object file main.o.
* Assertion: The generated command vector must contain sequences equivalent to ... -L/opt/lib... main.o... -lcurl.
* Failure Condition: If -lcurl appears before main.o in the vector, the test must fail, as this violates ELF symbol resolution ordering.4
Test Case: Windows FFI
* Configuration: TargetPlatform::Windows, libraries=["curl"], library_paths=["C:/libs"].
* Assertion: The generated command must contain /LIBPATH:C:/libs and curl.lib. It must also implicitly include the CRT libraries (libucrt.lib, etc.).
7.2 Integration Test: The libcurl Scenario
The primary driver for this feature is the std.net.http module.1 A complete integration test involves:
1. Dependency Prep: Using CMake/FetchContent to build libcurl statically, producing libcurl.a (Linux) or curl.lib (Windows).
2. Configuration: Creating a build.aria file that points to this output directory via the new library_paths field.
3. Execution: Running aria_make to build a simple HTTP client.
4. Verification: The resulting binary should execute and successfully initialize a CURL handle. If linking fails (e.g., due to missing OpenSSL symbols transitively required by CURL), the linker output captured in ExecResult.err_output must be parsed and presented clearly to the user.
8. Operational Considerations and Performance
8.1 Path Sanitization and Security
The integration of external paths introduces "Dependency Confusion" risks. If library_paths contains strings derived from untrusted user input, a malicious actor could inject linker flags. The architecture mandates the use of llvm::sys::ExecuteAndWait, which bypasses the system shell, combined with a rigorous escape_shell_arg function that quotes all arguments.1
8.2 Build Performance
Linking is slow. The enhanced orchestrator supports incremental linking where possible, but for release builds, Link Time Optimization (LTO) is desirable. The Target struct's flags field can accept -flto (passed to compilation) and the orchestrator passes -flto to the linker, enabling cross-module optimization.
9. Conclusion
The architectural enhancement of the ToolchainOrchestrator to support FFI linking represents a pivotal maturation of the AriaBuild system. By moving beyond simple compiler invocation to full-spectrum artifact orchestration, AriaBuild can now support the complex, hybrid applications demanded by modern systems programming. The design presented here rigorously addresses the platform-specific divergences of ELF and COFF linking, implementing safe, ordered, and sanitized command construction. By embedding logic to handle library prefixes, suffixes, and search paths transparently, it empowers Aria developers to define dependencies declaratively, confident that the build system will translate these intents correctly regardless of whether the host is running Linux, Windows, or macOS. This capability is the keystone for the "Gemini Work Package" and the future package ecosystem of the Aria language.
Table 1: Linker Flag Reference Table
Feature
	Linux/macOS Flag (GNU/LLVM)
	Windows Flag (MSVC/LLD-LINK)
	Implementation Logic
	Output File
	-o <file>
	/OUT:<file>
	Mapped from Target::output
	Lib Search Path
	-L<path>
	/LIBPATH:<path>
	Iterated from Target::library_paths
	Link Library
	-l<name>
	<name>.lib
	Iterated from Target::libraries
	Input Object
	<file>.o
	<file>.obj
	Passed from compile phase
	Debug Info
	-g (Compiler)
	/DEBUG
	Hardcoded default for safety
	Static Link
	-static
	N/A (Link distinct .lib)
	Configurable via build profile
	RPATH
	-Wl,-rpath,<path>
	N/A (Delay load / Copy)
	Calculated relative path
	Works cited
1. rcfull.txt
2. Use the Microsoft C++ Build Tools from the command line, accessed December 20, 2025, https://learn.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170
3. LIB vs LIBPATH (environment variables, difference for MS Visual C/C++)? - Stack Overflow, accessed December 20, 2025, https://stackoverflow.com/questions/20483619/lib-vs-libpath-environment-variables-difference-for-ms-visual-c-c
4. Cannot -static compile project for windows using mingw32 (x86_64-w64-mingw32-gcc) on mac (libstdc++-6.dll ) - Stack Overflow, accessed December 20, 2025, https://stackoverflow.com/questions/75702202/cannot-static-compile-project-for-windows-using-mingw32-x86-64-w64-mingw32-gcc
5. D65543 [Windows] Autolink with basenames and add libdir to libpath - LLVM Phabricator archive, accessed December 20, 2025, https://reviews.llvm.org/D65543
6. SwiftPM Windows: Link issues during build - Package Manager - Swift Forums, accessed December 20, 2025, https://forums.swift.org/t/swiftpm-windows-link-issues-during-build/24921
7. cinvesrob/Aria: MobileRobots' Advanced Robot Interface for Applications (ARIA) is a C++ library (software development toolkit or SDK) for all MobileRobots/ActivMedia platforms. - GitHub, accessed December 20, 2025, https://github.com/cinvesrob/Aria