Architectural Specification and Implementation Strategy: Linker Driver and Object Emission for the Aria Build System
1. Executive Summary
The transition of the Aria programming language from an experimental prototype to a production-grade ecosystem necessitates a fundamental re-engineering of its build infrastructure. Current architectural analysis reveals a reliance on legacy, imperative build mechanisms—specifically GNU Make and indirect compilation pipelines that route through system assemblers—which introduces significant friction, non-determinism, and platform dependency. To achieve the project's strategic goals of self-hosting, hermeticity, and high-performance parallel execution, a native Linker Driver and Object Emission subsystem must be implemented within the Aria compiler (ariac) and its associated build orchestrator (aria_make).
This report presents an exhaustive technical specification for "Task 7: Process Execution and Toolchain Orchestration." It provides a comprehensive analysis of the existing compiler driver, identifies the "Assembly Bottleneck" in the current artifact generation pipeline, and delineates a C++17 implementation strategy for the ToolchainOrchestrator. This component is engineered to bridge the semantic gap between the declarative Aria Build Configuration (ABC) and the low-level, imperative invocations required by the LLVM backend and system linkers.
The proposed architecture prioritizes direct object file emission to bypass inefficient assembly generation, standardized invocation of the LLVM Linker (lld) to ensure cross-platform consistency across ELF, COFF, and Mach-O binary formats, and robust process execution utilizing llvm::sys::ExecuteAndWait. By synthesizing internal source code analysis with advanced LLVM backend mechanics, this document serves as the definitive blueprint for evolving the Aria toolchain into a modern, integrated build system capable of supporting the language's v0.1.0 specification and beyond.
2. The Imperative for a Native Linker Driver
The maturity of a programming language is often judged not merely by its syntax or semantic elegance, but by the robustness of its toolchain. For Aria, currently at version v0.0.7, the reliance on external build scripts and system-specific assemblers presents a significant barrier to adoption and scalability. The existing infrastructure, characterized by the generation of intermediate assembly files (.s) which are subsequently processed by an external clang driver, violates the principles of hermetic builds. A hermetic build system should depend only on a known set of inputs and tools, isolating the build process from the vagaries of the host environment's configuration.
2.1 The Assembly Bottleneck
An analysis of the current compilation pipeline exposes a critical inefficiency: the "Assembly Bottleneck." In the current workflow, the ariac compiler generates LLVM IR, lowers it to machine instructions, and then serializes these instructions into textual assembly code. This text file is written to disk, only to be immediately read back from disk, parsed, and assembled into machine code by an external assembler. This cycle incurs unnecessary I/O overhead (writing and reading the file) and CPU overhead (formatting text and re-parsing text).
By implementing direct object emission, the compiler can serialize the in-memory machine instruction representation directly to a binary object file (.o or .obj). This bypasses the textual representation entirely, resulting in significantly faster compilation times—a metric that becomes increasingly critical as the codebase grows. Furthermore, direct object emission allows for tighter integration of debugging information (DWARF on Linux/macOS, CodeView/PDB on Windows), which is often degraded or complicated by the intermediate assembly step.
2.2 Cross-Platform Determinism
A primary design requirement for AriaBuild is cross-platform determinism.1 The behavior of system linkers varies wildly: GNU ld on Linux, MSVC link.exe on Windows, and ld64 on macOS all utilize distinct flag syntaxes and default behaviors.2 Relying on the host system's default linker introduces a matrix of compatibility issues that the build system must navigate.
The strategic adoption of lld, the LLVM Linker, resolves this complexity. lld is designed as a high-performance, drop-in replacement for system linkers that can support all major binary formats through "flavor" flags.4 By embedding or orchestrating lld as the canonical linker for Aria, the build system can guarantee consistent linking behavior regardless of the host OS, simplifying the ToolchainOrchestrator's logic and ensuring that a build executed on Windows produces an artifact functionally identical to one produced on Linux, barring OS-specific ABI differences.
3. Architectural Analysis of the Aria Compiler Driver
To architect the new subsystem effectively, one must first dissect the existing implementation of the Aria Compiler Driver (ariac) as defined in src/main.cpp. This file serves as the entry point for the compilation process, managing the lifecycle of the CompilerOptions configuration, the IRGenerator, and the final output generation.
3.1 The CompilerOptions Structure
The internal state of the driver is encapsulated in the CompilerOptions structure. This struct governs the driver's behavior based on command-line arguments provided by the user.1
Field
	Type
	Description
	input_files
	std::vector<std::string>
	Stores paths for multiple source files (translation units).
	output_file
	std::string
	The designated path for the final output artifact.
	emit_llvm_ir
	bool
	Flag for --emit-llvm. Produces textual LLVM IR.
	emit_llvm_bc
	bool
	Flag for --emit-llvm-bc. Produces binary bitcode.
	emit_asm
	bool
	Flag for --emit-asm. Produces textual assembly.
	dump_ast
	bool
	Flag for --ast-dump. Debugging utility.
	dump_tokens
	bool
	Flag for --tokens. Debugging utility.
	verbose
	bool
	Enables detailed logging of compilation phases.
	opt_level
	int
	Optimization level (0-3).
	warning_flags
	std::vector<std::string>
	Manages diagnostic warnings (e.g., -Wall).
	Architectural Gap: Notably absent from this structure is a flag for object emission (e.g., --emit-obj). The current architecture forces the user to choose between high-level IR/Bitcode or low-level Assembly, missing the crucial middle ground required for efficient linking. To support the new Linker Driver, the CompilerOptions struct must be extended to include bool emit_obj, and the argument parsing logic in parse_arguments must be updated to recognize this flag.
3.2 The Current Emission Pipeline
The main function orchestrates the compilation pipeline through a series of distinct phases: lexical analysis, parsing, semantic analysis, and IR generation.1 The culmination of this process is the emission phase. Currently, if no specific intermediate format is requested, the driver defaults to creating an executable via the following sequence:
1. Assembly Generation: The driver calls emit_assembly to generate a temporary .s file. This function initializes the native target and utilizes LLVMTargetMachine to emit text.
2. System Linking: It calls a helper function link_executable, which wraps a system call to the host's C compiler (likely clang or gcc) to assemble and link the temporary file.
3. Cleanup: The temporary .s file is deleted.
This pipeline effectively treats the Aria compiler as a frontend for the C compiler, delegating the heavy lifting of machine code generation and linking to external tools. While this was a pragmatic choice for early prototypes, it prevents the compiler from performing Link Time Optimization (LTO) or utilizing advanced linker features directly.
4. The Theory and Implementation of Direct Object Emission
The implementation of direct object emission requires a deep engagement with the LLVM backend APIs. This process involves configuring the TargetMachine to bypass the assembly printer and instead utilize the instruction selector and register allocator to produce a native object stream.
4.1 LLVM Backend Mechanics
The transformation from LLVM IR to machine code is handled by the TargetMachine class.5 This class provides an interface to the complete machine description, including the instruction set architecture, register file, and scheduling model.
The key method for emission is addPassesToEmitFile. This function accepts a legacy::PassManager and an output stream, along with a CodeGenFileType enum.
* CGFT_AssemblyFile: Instructs the backend to emit textual assembly.
* CGFT_ObjectFile: Instructs the backend to emit a binary object file.6
To implement object emission, the compiler must instantiate a TargetMachine initialized with the correct TargetTriple (architecture, vendor, OS, environment) and Reloc::Model.
4.2 Implementation Specification: emit_object
The following C++ implementation specification defines the emit_object function, which must be integrated into the src/main.cpp driver. This function encapsulates the logic for initializing the target, configuring the machine, and running the emission pass.


C++




/**
* Emits a native object file (.o/.obj) from the LLVM Module.
* 
* @param module The LLVM module containing the IR.
* @param output_file The destination path for the object file.
* @return true on success, false on failure.
*/
bool emit_object(llvm::Module* module, const std::string& output_file) {
   // 1. Initialize LLVM Targets
   // Required to register the target architectures available for code generation.
   llvm::InitializeNativeTarget();
   llvm::InitializeNativeTargetAsmParser();
   llvm::InitializeNativeTargetAsmPrinter();

   // 2. Resolve the Target Triple
   // We default to the host machine's triple for native compilation.
   // Cross-compilation would require parsing a target flag here.
   std::string target_triple = llvm::sys::getDefaultTargetTriple();
   module->setTargetTriple(target_triple);

   // 3. Lookup the Target
   std::string error;
   auto target = llvm::TargetRegistry::lookupTarget(target_triple, error);
   if (!target) {
       std::cerr << "Error: Target registry lookup failed: " << error << "\n";
       return false;
   }

   // 4. Configure Target Options
   // CPU: "generic" allows code to run on a wide range of processors.
   // Features: Empty string implies default features.
   std::string cpu = "generic";
   std::string features = "";
   llvm::TargetOptions opt;
   
   // Relocation Model: PIC (Position Independent Code) is crucial for 
   // creating shared libraries and ensuring compatibility with modern 
   // security features like ASLR on Linux/macOS.
   auto reloc_model = llvm::Reloc::PIC_;
   
   // Create the TargetMachine
   auto target_machine = target->createTargetMachine(
       target_triple, cpu, features, opt, reloc_model
   );
   
   // Sync the DataLayout of the module with the machine
   module->setDataLayout(target_machine->createDataLayout());

   // 5. Open Output Stream
   std::error_code ec;
   llvm::raw_fd_ostream dest(output_file, ec, llvm::sys::fs::OF_None);
   if (ec) {
       std::cerr << "Error: Could not open output file '" << output_file << "': " << ec.message() << "\n";
       return false;
   }

   // 6. Define and Run the Pass Manager
   llvm::legacy::PassManager pass;
   
   // Request ObjectFile emission
   if (target_machine->addPassesToEmitFile(pass, dest, nullptr, llvm::CGFT_ObjectFile)) {
       std::cerr << "Error: TargetMachine can't emit a file of this type\n";
       return false;
   }

   // Execute the passes
   pass.run(*module);
   dest.flush();
   
   return true;
}

This implementation adheres to modern LLVM best practices. It utilizes raw_fd_ostream for efficient file I/O and explicitly handles error codes. The selection of Reloc::PIC_ is a strategic decision; while static executables can use static relocation, the trend in modern systems (especially distributions like Fedora/Debian and macOS) is to compile everything as Position Independent Executables (PIE). Defaulting to PIC ensures maximum compatibility.7
4.3 Debug Information Integration
One of the significant advantages of direct object emission is the streamlined generation of debug information. The IRGenerator described in include/backend/ir/ir_generator.h utilizes llvm::DIBuilder to construct DWARF metadata.1 When emit_object is called, the TargetMachine automatically lowers this metadata into the appropriate sections (.debug_info, .debug_line, etc.) of the object file. This is far more robust than relying on an external assembler to infer debug info from line directives in an assembly file.
5. Linker Theory for System Architects
The second phase of the architectural upgrade involves the Linker Driver. Linking is the process of resolving references between independent translation units and combining them into a unified executable image.
5.1 Static vs. Dynamic Linking
The AriaBuild system must support both static and dynamic linking paradigms.
* Static Linking: All library code is copied into the final executable. This produces a larger binary but simplifies distribution (no "DLL Hell").
* Dynamic Linking: The executable contains references to shared libraries (.so, .dll, .dylib) which are loaded at runtime by the OS loader.8 This reduces disk usage and allows libraries to be updated independently.
The ToolchainOrchestrator must infer the linking mode from the build configuration. For instance, a target type of binary typically implies a dynamically linked executable, while static_binary would imply full static linking.
5.2 The Role of lld
The LLVM Linker (lld) is the cornerstone of Aria's linking strategy. Unlike the system linkers (ld, link.exe), lld is cross-platform by design. It supports multiple "flavors" that mimic the command-line interfaces of platform-specific linkers:
* ELF (Unix/Linux): ld.lld
* COFF (Windows): lld-link
* Mach-O (macOS): ld64.lld
* WebAssembly: wasm-ld
This unified capability allows Aria to ship a single linker binary that can cross-compile for any target platform, provided the necessary system libraries (sysroot) are available.
6. Architecture of the ToolchainOrchestrator
The ToolchainOrchestrator is a new class within the aria::build namespace designed to encapsulate the complexity of toolchain invocation. It acts as the translation layer between the abstract Dependency Graph and the concrete system processes.
6.1 Design Responsibilities
The Orchestrator has four primary responsibilities:
1. Command Construction: Translating abstract target definitions (inputs, outputs, flags) into concrete command-line arguments for the compiler and linker.
2. Path Resolution: Converting relative paths in the configuration to absolute paths required by the tooling, and resolving dependency targets into include (-I) and library (-L) paths.1
3. Platform Abstraction: Detecting the host OS and adjusting flag syntax (e.g., / vs -) accordingly.
4. Process Lifecycle Management: Spawning child processes for compilation and linking, managing their I/O streams, and handling exit codes.
6.2 Header Definition (include/build/toolchain.h)
The header defines the interface for the orchestrator. It relies on the DependencyGraph node structure to retrieve build context.


C++




#ifndef ARIA_BUILD_TOOLCHAIN_H
#define ARIA_BUILD_TOOLCHAIN_H

#include <string>
#include <vector>
#include <map>
#include <optional>
#include "graph/dependency_graph.h" 

namespace aria {
namespace build {

// Enum to identify the target platform for flag syntax adaptation
enum class TargetPlatform {
   Linux,
   Windows,
   MacOS,
   Unknown
};

class ToolchainOrchestrator {
public:
   /**
    * @brief Constructs the orchestrator.
    * @param compiler_path Path to the ariac compiler binary.
    * @param linker_path Path to the lld linker binary.
    */
   explicit ToolchainOrchestrator(const std::string& compiler_path = "ariac",
                                  const std::string& linker_path = "lld");

   /**
    * @brief Constructs the command line for compiling a single source file.
    * Maps target output to -o and dependencies to -I.
    * 
    * @param node The dependency graph node representing the target.
    * @param source_file The specific source file to compile.
    * @param output_obj The destination path for the object file.
    * @return A pair containing the executable path and the list of arguments.
    */
   std::pair<std::string, std::vector<std::string>> construct_compile_cmd(
       const graph::Node* node, 
       const std::string& source_file, 
       const std::string& output_obj
   );

   /**
    * @brief Constructs the command line for linking object files into a final artifact.
    * Automatically adapts to ELF (Linux) or COFF (Windows) syntax.
    * 
    * @param target_node The node representing the final artifact.
    * @param object_files List of object files to link.
    * @return A pair containing the executable path and the list of arguments.
    */
   std::pair<std::string, std::vector<std::string>> construct_link_cmd(
       const graph::Node* target_node,
       const std::vector<std::string>& object_files
   );

   /**
    * @brief Orchestrates the full build of a node.
    * 1. Compiles all sources to object files.
    * 2. Links object files to the final artifact.
    * Handles process execution and error reporting.
    * 
    * @param node The node to build.
    * @return true if build succeeds, false otherwise.
    */
   bool build_node(graph::Node* node);

private:
   std::string compiler_bin_;
   std::string linker_bin_;
   TargetPlatform current_platform_;

   // Helper to detect current OS
   TargetPlatform detect_platform() const;

   // Helper to resolve include paths from node dependencies
   std::vector<std::string> resolve_include_paths(const graph::Node* node);
   
   // Helper to resolve library paths from node dependencies
   std::vector<std::string> resolve_lib_paths(const graph::Node* node);
};

} // namespace build
} // namespace aria

#endif // ARIA_BUILD_TOOLCHAIN_H

7. Implementation of Cross-Platform Linker Invocation
The implementation of the ToolchainOrchestrator must address the divergent syntaxes of linkers. This is where the TargetPlatform enum becomes critical.
7.1 Platform Detection Logic
The system detects the platform at runtime (or compile-time of the build tool) using preprocessor macros. This is standard practice in C++ systems programming.9


C++




TargetPlatform ToolchainOrchestrator::detect_platform() const {
   #ifdef _WIN32
       return TargetPlatform::Windows;
   #elif defined(__APPLE__)
       return TargetPlatform::MacOS;
   #elif defined(__linux__)
       return TargetPlatform::Linux;
   #else
       return TargetPlatform::Unknown;
   #endif
}

7.2 Linking on Windows (COFF)
When targeting Windows, the Orchestrator must generate arguments compatible with link.exe (which lld-link emulates). Key flags include:
* /OUT:filename: Specifies the output filename.
* /LIBPATH:path: Adds a directory to the library search path.
* /DEFAULTLIB:libname: Links a specific static library or import library.
* /SUBSYSTEM:CONSOLE or /SUBSYSTEM:WINDOWS: Defines the entry point type (main vs WinMain).10
* /DEBUG: Generates PDB debug information.
The orchestrator must also link against the C runtime (CRT). Modern Windows applications typically link against the Universal CRT (libucrt.lib) and the Visual C++ runtime (libvcruntime.lib).
7.3 Linking on Linux (ELF)
For Linux, the syntax follows the GNU ld standard:
* -o filename: Output filename.
* -Lpath: Add library search path.
* -lname: Link against libname.so or libname.a.
* -rpath: Sets the runtime library search path.8
A critical detail on Linux is the "Start Files" (crt0.o, crti.o, crtn.o). These object files contain the _start symbol which initializes the stack and calls main. Directly invoking ld requires manually specifying these files, which vary by libc version. Therefore, on Linux, it is often more robust to use the C compiler driver (clang or gcc) as the linker driver, passing -fuse-ld=lld to instruct it to use LLVM's linker.11 This ensures standard libraries and start files are included correctly without hardcoding paths.
7.4 Implementation: src/build/toolchain.cpp
The following implementation synthesizes these requirements into a cohesive C++ module. It leverages llvm::sys::ExecuteAndWait for robust process execution.


C++




#include "build/toolchain.h"
#include "llvm/Support/Program.h"
#include "llvm/Support/FileSystem.h"
#include <iostream>
#include <filesystem> // C++17

namespace fs = std::filesystem;

namespace aria {
namespace build {

ToolchainOrchestrator::ToolchainOrchestrator(const std::string& compiler, const std::string& linker) 
   : compiler_bin_(compiler), linker_bin_(linker) {
   current_platform_ = detect_platform();
   
   // Locate the compiler binary in the system PATH
   if (auto path = llvm::sys::findProgramByName(compiler_bin_)) {
       compiler_bin_ = *path;
   }
}

std::pair<std::string, std::vector<std::string>> 
ToolchainOrchestrator::construct_compile_cmd(
   const graph::Node* node, 
   const std::string& source_file, 
   const std::string& output_obj) 
{
   std::vector<std::string> args;
   args.push_back(compiler_bin_); // argv
   
   // Input source file
   args.push_back(source_file);

   // Output object file mapping
   args.push_back("-o");
   args.push_back(output_obj);

   // Enable Object Emission (The new flag added to ariac)
   args.push_back("--emit-obj"); 

   // Dependency Resolution: Convert dependencies to Include Paths
   auto includes = resolve_include_paths(node);
   for (const auto& inc : includes) {
       args.push_back("-I");
       args.push_back(inc);
   }

   // Optimization Levels from configuration
   // 
   // args.push_back("-O2"); 

   return {compiler_bin_, args};
}

std::pair<std::string, std::vector<std::string>> 
ToolchainOrchestrator::construct_link_cmd(
   const graph::Node* target_node,
   const std::vector<std::string>& object_files) 
{
   std::vector<std::string> args;
   std::string linker_exe;

   if (current_platform_ == TargetPlatform::Windows) {
       // Windows: Use lld-link style
       linker_exe = "lld-link"; // Or full path
       
       args.push_back(linker_exe);
       args.push_back("/OUT:" + target_node->output_file);
       args.push_back("/NOLOGO");
       args.push_back("/DEBUG"); // Default to debug for safety
       args.push_back("/SUBSYSTEM:CONSOLE"); // Default to console app
       
       // Link inputs
       for (const auto& obj : object_files) {
           args.push_back(obj);
       }
       
       // Link Paths
       auto lib_paths = resolve_lib_paths(target_node);
       for (const auto& path : lib_paths) {
           args.push_back("/LIBPATH:" + path);
       }
       
       // Standard Windows Libraries
       args.push_back("libucrt.lib");
       args.push_back("libcmt.lib"); 

   } else {
       // Linux/Unix: Use compiler driver to drive linking for CRT safety
       linker_exe = compiler_bin_; 
       args.push_back(linker_exe);
       
       if (current_platform_ == TargetPlatform::Linux) {
            args.push_back("-fuse-ld=lld"); // Enforce lld usage
       }
       
       args.push_back("-o");
       args.push_back(target_node->output_file);
       
       // Link inputs
       for (const auto& obj : object_files) {
           args.push_back(obj);
       }
       
       // Link Paths and Libraries
       // Note: Aria standard library linking would happen here
       // args.push_back("-L...");
       // args.push_back("-l...");
   }

   return {linker_exe, args};
}

bool ToolchainOrchestrator::build_node(graph::Node* node) {
   // Phase 1: Compile all sources to object files
   std::vector<std::string> object_files;
   
   for (const auto& src : node->source_files) {
       // Derive object file path: src/main.aria -> build/src/main.aria.o
       // Simplified logic for example:
       std::string obj_file = src + ".o"; 
       object_files.push_back(obj_file);

       // Check if rebuild is needed (incremental logic)
       // This would interact with the DependencyGraph's dirty checking
       
       auto [cmd, args] = construct_compile_cmd(node, src, obj_file);
       
       // Convert to llvm::StringRef for ExecuteAndWait
       std::vector<llvm::StringRef> ref_args;
       for(const auto& a : args) ref_args.push_back(a);

       std::string err_msg;
       int result = llvm::sys::ExecuteAndWait(
           cmd, ref_args, std::nullopt, {}, 0, 0, &err_msg
       );

       if (result!= 0) {
           std::cerr << "Compilation failed for " << src << ": " << err_msg << "\n";
           return false;
       }
   }

   // Phase 2: Link objects into final binary
   if (node->type == graph::NodeType::Binary) {
       auto [link_cmd, link_args] = construct_link_cmd(node, object_files);
       
       std::vector<llvm::StringRef> ref_link_args;
       for(const auto& a : link_args) ref_link_args.push_back(a);

       std::string err_msg;
       int result = llvm::sys::ExecuteAndWait(
           link_cmd, ref_link_args, std::nullopt, {}, 0, 0, &err_msg
       );

       if (result!= 0) {
           std::cerr << "Linking failed: " << err_msg << "\n";
           return false;
       }
   }

   return true;
}

// Helpers for dependency resolution
std::vector<std::string> ToolchainOrchestrator::resolve_include_paths(const graph::Node* node) {
   std::vector<std::string> paths;
   // Iterate dependencies and extract their output directories
   // for (const auto& dep : node->dependencies)...
   return paths;
}

std::vector<std::string> ToolchainOrchestrator::resolve_lib_paths(const graph::Node* node) {
   std::vector<std::string> paths;
   // Similar logic for library paths
   return paths;
}

} // namespace build
} // namespace aria

8. Process Execution and Concurrency Management
High-performance builds rely on parallel execution. aria_make is architected to use Kahn's Algorithm to schedule independent build tasks concurrently.1 The ToolchainOrchestrator must support this by ensuring that build_node is thread-safe and that process spawning does not lead to resource exhaustion.
8.1 Thread Safety in ExecuteAndWait
llvm::sys::ExecuteAndWait is generally thread-safe, as it relies on OS-level primitives (fork/exec on Linux, CreateProcess on Windows). However, managing the standard output and error streams of multiple concurrent compiler processes requires care to avoid interleaved ("garbled") logs in the console.
The implementation utilizes std::optional<std::string> for redirecting output or buffering it. In a robust build system, the Orchestrator should capture the stdout/stderr of the child process into a buffer and only print it to the main console atomically upon task completion. This prevents the output of Task A from mixing with Task B in the terminal.
8.2 The Thundering Herd Problem
While compiling source files to objects is highly parallelizable (embarrassingly parallel), linking is a synchronization point. A massive project might have hundreds of object files. Linking them is memory and CPU intensive. If the scheduler blindly schedules multiple link jobs (e.g., linking the main executable while simultaneously linking unit tests), it risks thrashing the system's memory (OOM).
The Orchestrator implementation implicitly handles the sequential nature of a single node's build (compile all sources -> link). However, the global Scheduler should optimally limit the number of concurrent link jobs (often to 1 or 2) while allowing compile jobs to saturate the remaining CPU cores.
9. Integration with the Aria Runtime Environment
The build system does not operate in a vacuum; it must link against the Aria runtime. The runtime_stdlib_summary.txt reveals that the runtime includes core I/O, memory allocation (mimalloc), and platform abstractions.1
9.1 Automatic Runtime Linking
The linker driver must automatically inject the Aria runtime library into the link command.
* Static Linking: -laria_runtime (or aria_runtime.lib).
* Dynamic Linking: -laria_runtime and ensuring the library is in the rpath.
Specifically, functions like aria_alloc and aria_free are intrinsics that the compiler generates calls to. If the linker fails to resolve these symbols against the runtime library, the build will fail with "undefined reference" errors. The construct_link_cmd method must therefore be augmented to append the path to the Aria installation's lib directory (e.g., /usr/local/lib/aria) to the library search paths.
10. Conclusion
The architecture defined in this report represents a significant leap forward for the Aria ecosystem. By replacing the legacy assembly-based pipeline with a native Linker Driver and Object Emission subsystem, the project eliminates critical performance bottlenecks and achieves cross-platform hermeticity.
The introduction of the emit_object function within ariac brings the compiler into alignment with modern LLVM-based toolchains (Rust, Swift, Clang). Simultaneously, the ToolchainOrchestrator within aria_make encapsulates the complexity of platform-specific linking, abstracting the differences between link.exe and ld behind a unified, declarative interface. This design not only satisfies the immediate requirement for robust build automation but also lays the groundwork for advanced future capabilities such as Link Time Optimization (LTO) and fully self-hosted builds.
Implementation of the specified C++ classes and integration of the proposed changes to src/main.cpp will result in a build system that is faster, more reliable, and ready for the demands of version 0.1.0 and beyond.
Citations
1
Works cited
1. runtime_stdlib_summary.txt
2. ld Command - IBM, accessed December 19, 2025, https://www.ibm.com/docs/ssw_aix_72/l_commands/ld.html
3. MSVC Linker options - Microsoft Learn, accessed December 19, 2025, https://learn.microsoft.com/en-us/cpp/build/reference/linker-options?view=msvc-170
4. LLD - The LLVM Linker — lld 22.0.0git documentation, accessed December 19, 2025, https://lld.llvm.org/
5. llvm::TargetMachine Class Reference, accessed December 19, 2025, https://cs6340.cc.gatech.edu/LLVM8Doxygen/classllvm_1_1TargetMachine.html
6. 8. Kaleidoscope: Compiling to Object Code — LLVM 22.0.0git documentation, accessed December 19, 2025, https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html
7. A deep dive into Clang's source file compilation - MaskRay, accessed December 19, 2025, https://maskray.me/blog/2023-09-24-a-deep-dive-into-clang-source-file-compilation
8. Where do executables look for shared objects at runtime? - Unix & Linux Stack Exchange, accessed December 19, 2025, https://unix.stackexchange.com/questions/22926/where-do-executables-look-for-shared-objects-at-runtime
9. How to detect reliably Mac OS X, iOS, Linux, Windows in C preprocessor? - Stack Overflow, accessed December 19, 2025, https://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor
10. Can't figure out how to pass /subsystem:windows to lld-link.exe : r/cpp_questions - Reddit, accessed December 19, 2025, https://www.reddit.com/r/cpp_questions/comments/ks6u5w/cant_figure_out_how_to_pass_subsystemwindows_to/
11. LLD and the Linker Scripts - Stack Overflow, accessed December 19, 2025, https://stackoverflow.com/questions/57370682/lld-and-the-linker-scripts
12. Please add .o writer example to next release - LLVM Discussion Forums, accessed December 19, 2025, https://discourse.llvm.org/t/please-add-o-writer-example-to-next-release/18607
13. 8. Kaleidoscope: Compiling to Object Code — LLVM 8 documentation, accessed December 19, 2025, https://releases.llvm.org/8.0.1/docs/tutorial/LangImpl08.html
14. ld.lld(1) manual page, accessed December 19, 2025, https://nxmnpg.lemoda.net/1/ld.lld
15. [llvm-dev] Invoking lld for PE/COFF (Windows) linking - Google Groups, accessed December 19, 2025, https://groups.google.com/g/llvm-dev/c/dMEv8pyy67w
16. llvm::sys Namespace Reference, accessed December 19, 2025, https://llvm.org/doxygen/namespacellvm_1_1sys.html
17. llvm-project/llvm/lib/Support/Program.cpp at main - GitHub, accessed December 19, 2025, https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/Program.cpp