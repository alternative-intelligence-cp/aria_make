Architectural Specification: Comprehensive Implementation of Transitive Dependency Propagation in AriaBuild (Task 3.3)
1. Executive Summary and Strategic Context
1.1 The Evolution of the Aria Ecosystem
The Aria programming language, currently positioned at version 0.0.7, represents a significant leap forward in systems programming, introducing novel paradigms such as Twisted Balanced Binary (TBB) arithmetic, a hybrid memory model capable of managing both garbage-collected and "wild" (manual) allocation, and a rigid, explicit module system.1 As the language specification stabilizes and moves toward the pivotal v0.1.0 milestone, the supporting infrastructure must evolve from experimental tooling to enterprise-grade robustness. At the heart of this infrastructure lies AriaBuild (internally referenced as aria_make), a deterministic, declarative build system designed to orchestrate the compilation of Aria's unique syntax and semantics.1
AriaBuild operates on a "Configuration as Data" philosophy, rejecting the imperative scripting models of legacy tools like GNU Make in favor of a rigorous, whitespace-insensitive JSON-derivative syntax known as the Aria Build Configuration (ABC) format.1 This design choice prioritizes readability, determinism, and tooling integration. However, as the complexity of Aria projects increases—moving from simple single-file scripts to multi-module monorepos—a critical architectural deficiency has emerged within the dependency management subsystem.
1.2 The Dependency Propagation Bottleneck
The current architecture of AriaBuild enforces a strict, manual declaration of dependencies. While the DependencyGraph engine successfully models the build universe as a Directed Acyclic Graph (DAG) for the purpose of scheduling execution order using Kahn’s Algorithm 1, it fails to automate the propagation of compilation context (specifically, include paths and linker flags) across the graph.
Currently, if a target App depends on a library LibA, and LibA depends on LibB, the developer of App is forced to explicitly list both LibA and LibB in the depends_on configuration of App. This phenomenon, known as "Manual Listing", has two deleterious effects:
1. Broken Encapsulation: The consumer (App) must be intimately aware of the internal implementation details of its direct dependency (LibA). If LibA is refactored to replace LibB with LibC, the build configuration for App breaks, despite App's code remaining unchanged.
2. Verbose Configuration: As dependency trees deepen, the depends_on lists in leaf-node targets explode in size, listing dozens of transitive dependencies that are irrelevant to the target's immediate logic. This increases the cognitive load on developers and introduces a high risk of "stale dependency" errors.
1.3 Objective: Automated Transitive Resolution
Task 3.3 mandates a comprehensive architectural intervention to resolve this bottleneck. The objective is to enhance the DependencyGraph engine by implementing a recursive resolve_flags() mechanism. This mechanism will traverse the dependency DAG to calculate the Transitive Closure of compiler flags, automatically aggregating public include paths and linker instructions from deep dependencies and bubbling them up to the consumer.
This report provides the definitive architectural blueprint for this implementation. It synthesizes the theoretical underpinnings of graph traversal algorithms, the specific C++ implementation details required for the AriaBuild codebase (utilizing std::filesystem and modern C++17 paradigms), and the integration logic for the ToolchainOrchestrator.1 The successful execution of this task is a prerequisite for scaling the Aria ecosystem, ensuring that the build tool embodies the same principles of safety and abstraction as the language it serves.
________________
2. Architectural Analysis of the Current System (As-Is)
To design a robust solution, one must first perform a rigorous forensic analysis of the existing AriaBuild architecture. This analysis identifies the specific structural limitations that necessitate the proposed changes and establishes the baseline for integration.
2.1 The Dependency Graph Engine
The core of AriaBuild is the DependencyGraph class. As described in the architectural specification, this component is responsible for modeling the build process as a DAG where nodes ($V$) represent build entities and edges ($E$) represent dependency relationships.1
2.1.1 Node Structure and Schema
The Node class encapsulates the metadata for a single build target. Based on the target schema defined in the configuration 1, a node contains:
* Identity: A unique name and a type (binary, library, test).
* Inputs: A list of sources, often populated via recursive globbing (e.g., src/**/*.aria).
* Dependencies: A list of strings in the depends_on field, representing explicit edges to other nodes.
* Outputs: An output path for the generated artifact (typically .ll LLVM IR files).
* Direct Flags: A flags list containing explicit compiler arguments (e.g., -O3, -DDEBUG).
2.1.2 Execution Scheduling vs. Flag Propagation
Crucially, the current system distinguishes between scheduling and flag generation, but only implements complexity for the former. The DependencyGraph uses Kahn’s Algorithm to perform a topological sort.1 This algorithm calculates the in-degree of every node (the number of incoming dependencies). Nodes with an in-degree of 0 are added to a "Ready Queue," and as they complete, they decrement the in-degree of their dependents.
This logic ensures that LibB is compiled before LibA, and LibA before App. However, it does not manage the flow of metadata. When App is compiled, the system merely checks that LibA exists. It does not ask LibA, "What do you need?" This decoupling of temporal ordering (scheduling) from spatial configuration (flags) is the root cause of the "Manual Listing" issue.
2.2 The Toolchain Orchestration Layer
The ToolchainOrchestrator acts as the "meta-driver" for the build process, bridging the gap between the high-level graph and the low-level ariac compiler.1
2.2.1 Current Command Construction Logic
The orchestration logic for constructing a compile command is currently linear and shallow. As inferred from the existing specification 1, the logic proceeds as follows:
1. Binary Resolution: Locate the ariac compiler binary.
2. Output Mapping: Map the target's output field to the -o flag.
3. Direct Dependency Iteration: Iterate through the depends_on list of the current target only.
   * For each dependency D, resolve its output directory.
   * Append an include flag -I path/to/D to the command line.
4. Source Appending: Append source files and direct flags.
2.2.2 The Failure Mode
Consider the diamond dependency scenario:
* Target Core: Exports core.aria.
* Target Utils: Depends on Core. Uses core.aria types in its public headers.
* Target App: Depends on Utils.
When the Orchestrator builds App:
1. It looks at App.depends_on, which contains ["Utils"].
2. It adds -I build/Utils.
3. It invokes ariac.
The ariac compiler processes App/main.aria, which contains use Utils;. It finds Utils, but Utils contains use Core;. Since -I build/Core was not passed to the compiler (because Core is not in App's direct dependency list), the compilation fails with a "Module Not Found" error. The developer is forced to add Core to App's dependencies manually, breaking the abstraction.
2.3 Integration with the Aria Compiler (ariac) and LSP
The constraint is further tightened by the nature of the Aria compiler and Language Server (AriaLS). The compiler frontend (Lexer, Parser, Semantic Analysis) is a single-pass, blocking system.1 It requires all symbol definitions to be available during the parse phase. It does not support "lazy loading" of missing modules from the network; it strictly respects the provided include paths (-I).
Furthermore, the AriaLS relies on the build system's compile_commands.json output to provide IntelliSense.1 If the build system fails to generate the complete set of transitive includes, the Language Server will show "red squiggles" for transitive types, degrading the developer experience. Thus, the fix in Task 3.3 is critical not just for compilation success, but for the entire IDE ecosystem.
________________
3. Theoretical Framework: Transitive Closure and Flag Aggregation
To engineer a solution that is both correct and scalable, we must formalize the problem using graph theory. The "Dependency Propagation" problem is mathematically equivalent to computing the Transitive Closure of properties over a Directed Acyclic Graph.
3.1 Mathematical Formulation of Flag Propagation
Let $G = (V, E)$ be the dependency graph.
For each node $u \in V$, let $F_{direct}(u)$ be the set of explicit flags defined in $u$'s configuration. These include:
* $I_{direct}(u)$: The include path for node $u$ itself (e.g., its output directory).
* $L_{direct}(u)$: The linker flag for node $u$ itself (e.g., linking the library generated by $u$).
We define $R(u)$, the Resolved Flags for target $u$, as the union of its direct flags and the resolved flags of all its outgoing neighbors (dependencies).




$$R(u) = F_{direct}(u) \cup \bigcup_{v \in \text{children}(u)} R(v)$$
This recursive definition highlights two key requirements:
1. Recursion: Calculating $R(u)$ requires calculating $R(v)$ for all dependencies $v$.
2. Aggregation: The results must be merged into a single coherent set.
3.2 The Diamond Dependency Challenge and Deduplication
In real-world projects, dependency graphs are rarely trees; they are complex DAGs often featuring "diamond" patterns.
* $A \to B \to D$
* $A \to C \to D$
If we naively apply the recursive formula by concatenating lists, the flags for $D$ will appear twice in $R(A)$: once via $B$ and once via $C$.




$$R(A) = \{ \dots, F(D), \dots, F(D) \}$$
Duplicate flags cause varying degrees of harm:
* Include Paths (-I): Generally harmless but inefficient. Duplicates lengthen the command line and can slightly slow down compiler search times.
* Linker Flags (-l): Potentially catastrophic. Linking the same static library twice can lead to "Multiple Definition" errors in the linker, or circular reference issues depending on the linker implementation (ld vs lld).
* Defines (-D): Harmless if identical, but conceptually redundant.
Requirement: The resolve_flags algorithm must implement strict Deduplication. Ideally, it should possess a mechanism to remember which nodes have already been visited within the current traversal context, or leverage memoization to cache the result of $R(D)$ so it is computed only once.
3.3 Ordering Semantics: Topological vs. Reverse
The order in which flags appear on the command line matters, particularly for linkers.
* Include Paths: Order determines search priority. If a "shadowed" header exists in two directories, the first one wins. Generally, dependencies closer to the root (the target being built) should take precedence to allow for overrides.
* Linker Flags: Traditional UNIX linkers (like GNU ld) require reverse topological order. If A depends on B, A must appear before B on the command line so the linker knows A has unresolved symbols that B provides. However, modern linkers and the ariac driver often handle this more gracefully, or the build system explicitly manages groups (e.g., --start-group... --end-group).
For AriaBuild, we will adopt a Post-Order Traversal strategy for collection. We visit dependencies before adding the parent's flags. This naturally accumulates flags from the leaves up to the root. By reversing this list (or appending to the end), we can satisfy the specific ordering needs of the toolchain. For -I flags, breadth-first or topological ordering is usually preferred; for Task 3.3, we will prioritize correctness (ensuring existence) and uniqueness.
3.4 Encapsulation and Visibility Scopes
Advanced build systems like CMake or Bazel distinguish between PUBLIC, PRIVATE, and INTERFACE dependencies.
* PUBLIC: Dependency is used in the implementation and exposed in the interface. Propagates transitively.
* PRIVATE: Dependency is used only in implementation. Does not propagate.
The current AriaBuild specification does not support these keywords in the depends_on list.1 Therefore, to safely solve the "Broken Encapsulation" issue mandated by the prompt, we must treat all dependencies as PUBLIC (Transitive). This is a safe "over-approximation." It ensures correctness at the cost of potentially exposing more include paths than strictly necessary, which is acceptable for the current maturity level of the Aria ecosystem (v0.0.7). Future versions of the ABC syntax can introduce visibility modifiers.
________________
4. Detailed Design Specification: DependencyGraph::resolve_flags()
This section articulates the specific modifications to the C++ codebase required to implement Task 3.3. It details the augmentation of the Node class and the logic of the resolve_flags method.
4.1 Data Structure Augmentation: The Node Class
The Node class 1 currently stores static configuration data (flags, depends_on). To support efficient transitive resolution, we must augment it with a cache structure. Re-traversing the entire subgraph for every node in a large build would lead to $O(V \times (V+E))$ complexity, which is unacceptable for performance. We introduce Memoization to reduce this to $O(V+E)$.
4.1.1 The ResolvedConfiguration Struct
We define a helper structure to hold the aggregated results. This structure separates include paths from link flags, as they are consumed differently by the orchestrator.


C++




namespace aria::build {

struct ResolvedConfiguration {
   // Aggregated list of include directories (-I)
   std::vector<std::string> include_paths;
   
   // Aggregated list of linker flags/libraries (-l, -L)
   std::vector<std::string> link_flags;
   
   // Aggregated list of preprocessor definitions (-D)
   std::vector<std::string> defines;
   
   // State flag for memoization
   bool is_cached = false;
};

}

4.1.2 Extending class Node
The Node class is updated to include this cache.


C++




class Node {
public:
   //... Existing members (name, sources, output, etc.)...

   // New member: Cache for transitive resolution
   mutable ResolvedConfiguration resolved_cache;

   // Existing direct flags from build.aria
   std::vector<std::string> flags; 
   
   // Helper to access direct output directory (for -I generation)
   std::string get_include_dir() const;
};

4.2 The resolve_flags Algorithm
The DependencyGraph::resolve_flags method implements the recursive traversal. It operates in two phases: Collection and Deduplication.
4.2.1 Deduplication Strategy
To maintain the required order while ensuring uniqueness, we utilize a standard "Vector + Set" idiom.
* std::vector: Maintains the order of insertion (deterministic).
* std::unordered_set: Provides $O(1)$ lookups to check if an item has already been added.
4.2.2 Recursive Logic
The algorithm follows these steps for a given node Target:
1. Check Cache: If Target->resolved_cache.is_cached is true, return the cached object immediately.
2. Initialize: Create a new ResolvedConfiguration and the deduplication sets.
3. Recurse: Iterate through Target->dependencies (the adjacency list derived from depends_on).
   * Call resolve_flags(Dependency) to get the dependency's transitive configuration.
   * Merge: Append the dependency's transitive includes/flags to the current configuration, checking against the deduplication set.
4. Add Direct:
   * Add the dependency's own output directory as an include path.
   * Add the dependency's own output artifact as a link flag (if it is a library).
5. Finalize: Mark is_cached = true and return the result.
4.3 Handling Cycles
While the DependencyGraph has a CycleDetector utilizing DFS Tri-Color marking 1 to prevent cycles during the build phase, the resolve_flags method should theoretically be robust against them to prevent stack overflows if the graph is malformed. However, since resolve_flags is invoked after the graph has been validated and topologically sorted, we can assume the graph is a DAG. A simple recursion depth guard can be added as a defensive programming measure.
________________
5. Implementation Specification
The following C++ implementation provides the concrete logic for the src/graph/dependency_graph.cpp file. It utilizes std::filesystem (aliased as fs) as mandated by the AriaBuild architectural standards 1 to manipulate paths robustly.
5.1 Header Definition (include/graph/dependency_graph.h)


C++




#pragma once
#include <vector>
#include <string>
#include <unordered_set>
#include <memory>
#include "node.h"

namespace aria::build {

// Helper struct for cached results
struct ResolvedContext {
   std::vector<std::string> includes;
   std::vector<std::string> links;
   bool valid = false;
};

class DependencyGraph {
public:
   //... existing topological sort and node management methods...

   /**
    * @brief Recursively resolves transitive flags for a target.
    * 
    * Walks the dependency tree to aggregate include paths and linker flags.
    * Implements memoization to ensure O(N) performance over the graph.
    * 
    * @param target The node to resolve.
    * @return ResolvedContext containing deduplicated, ordered flags.
    */
   const ResolvedContext& resolve_flags(Node* target);

private:
   // Internal helper for the recursive step
   void collect_transitive_flags(Node* node, 
                                 ResolvedContext& ctx, 
                                 std::unordered_set<std::string>& seen_includes,
                                 std::unordered_set<std::string>& seen_links);
};

}

5.2 Source Implementation (src/graph/dependency_graph.cpp)


C++




#include "graph/dependency_graph.h"
#include <filesystem>

namespace aria::build {

const ResolvedContext& DependencyGraph::resolve_flags(Node* target) {
   // 1. Memoization Check
   // We store the cache on the Node itself to persist across calls
   if (target->resolved_cache.valid) {
       return target->resolved_cache;
   }

   ResolvedContext ctx;
   std::unordered_set<std::string> seen_includes;
   std::unordered_set<std::string> seen_links;

   // 2. Recursive Collection
   // We iterate over the direct dependencies of the target.
   // For each dependency, we collect its transitive closure.
   for (Node* dep : target->get_dependencies()) {
       collect_transitive_flags(dep, ctx, seen_includes, seen_links);
   }

   // 3. Cache and Return
   ctx.valid = true;
   target->resolved_cache = ctx;
   return target->resolved_cache;
}

void DependencyGraph::collect_transitive_flags(Node* node, 
                                              ResolvedContext& ctx, 
                                              std::unordered_set<std::string>& seen_includes,
                                              std::unordered_set<std::string>& seen_links) {
   
   // A. Recurse Deeper First (Depth-First Post-Order)
   // This ensures that flags from the deepest dependencies appear first (or last, depending on insertion),
   // allowing for consistent ordering.
   // Note: We might want to resolve the dependency's flags first if we haven't already.
   if (!node->resolved_cache.valid) {
       resolve_flags(node);
   }
   const auto& dep_ctx = node->resolved_cache;

   // B. Merge Transitive Flags from Dependency
   for (const auto& inc : dep_ctx.includes) {
       if (seen_includes.insert(inc).second) {
           ctx.includes.push_back(inc);
       }
   }
   for (const auto& link : dep_ctx.links) {
       if (seen_links.insert(link).second) {
           ctx.links.push_back(link);
       }
   }

   // C. Add the Dependency ITSELF
   // 1. Include Path: The directory containing the dependency's output
   // Assuming output is "build/lib/libA.a" or "build/mod/A.ll"
   std::filesystem::path out_path(node->output_file);
   std::string inc_dir = out_path.parent_path().string();
   
   if (seen_includes.insert(inc_dir).second) {
       ctx.includes.push_back(inc_dir);
   }

   // 2. Link Flag: If the dependency is a library, link it.
   if (node->type == NodeType::LIBRARY) {
       // Construct linker flag. Simple approach: path to artifact
       // Advanced approach: -L dir -l name
       // For LLVM/ariac, passing the.ll/.bc file directly is often supported
       std::string link_arg = node->output_file;
       if (seen_links.insert(link_arg).second) {
           ctx.links.push_back(link_arg);
       }
   }
}

} // namespace aria::build

________________
6. Integration with Toolchain Orchestration
The final piece of the architecture involves modifying the ToolchainOrchestrator to consume the data generated by resolve_flags.
6.1 Refactoring construct_compile_cmd
The previous implementation iterated only over target->depends_on. The new implementation delegates discovery to the graph.


C++




std::vector<std::string> ToolchainOrchestrator::construct_compile_cmd(Node* target) {
   std::vector<std::string> args;
   args.push_back(compiler_path_);
   
   //... Input files...

   // NEW: Resolve Transitive Flags
   // The graph performs the heavy lifting of recursion and deduplication
   auto resolved_flags = graph_->resolve_flags(target);

   // Apply Transitive Includes
   for (const auto& inc : resolved_flags.includes) {
       args.push_back("-I");
       args.push_back(inc);
   }

   // Apply Output
   args.push_back("-o");
   args.push_back(target->output_file);

   return args;
}

6.2 Linking Implications
For the link step (if ariac handles linking or if lli is used), the resolved_flags.links vector provides the complete list of transitive libraries. This ensures that if App uses LibA, and LibA uses LibB, the final link command will correctly include LibB without the developer of App needing to know it exists.
________________
7. Operational Analysis: Performance, Testing, and Migration
7.1 Performance Impact
The introduction of recursive resolution introduces computational overhead. However, the architectural decision to use Memoization neutralizes this risk.
* Without Memoization: Complexity is exponential in the worst case (dense DAGs).
* With Memoization: Complexity is Linear $O(V+E)$. Each edge is traversed exactly once.
* Caching: The ResolvedConfiguration is computed lazily and cached. Subsequent queries (e.g., by IDE tooling or during linking phases) are $O(1)$.
Table 1 summarizes the performance characteristics:
Metric
	Current System
	New System (Recursive)
	New System (Memoized)
	Complexity
	$O(1)$ (Direct Only)
	$O(2^V)$ (Worst Case)
	$O(V + E)$
	Memory Overhead
	Minimal
	High (Stack depth)
	Moderate (String storage)
	Correctness
	Low (Manual)
	High (Auto)
	High (Auto)
	7.2 Validation and Testing Strategy
Verification of this feature requires a suite of graph topology tests using the project's test harness.
* Test Case A (Linear Chain): $A \to B \to C$. Verify $A$ gets -I C.
* Test Case B (Diamond): $A \to B \to D$ and $A \to C \to D$. Verify $A$ gets -I D exactly once.
* Test Case C (Cycle): $A \to B \to A$. Verify the CycleDetector catches this before resolve_flags enters infinite recursion (or rely on recursion depth limits as a failsafe).
7.3 Migration for Developers
This change is backward compatible but allows for configuration cleanup.
* Step 1: Upgrade AriaBuild. Existing build.aria files will work, but may have redundant -I flags generated (due to manual listing + automatic propagation). Deduplication handles this safely.
* Step 2: Prune depends_on. Developers can remove transitive dependencies from their targets.
   * Before: depends_on:
   * After: depends_on:
________________
8. Conclusion
The implementation of DependencyGraph::resolve_flags represents a critical maturity milestone for the Aria ecosystem. By automating the resolution of transitive dependencies, we shift the burden of graph management from the human developer to the build system, enforcing strict encapsulation and significantly reducing configuration verbosity.
This architectural blueprint satisfies the requirements of Task 3.3 by providing:
1. Recursive Collection: A DFS-based traversal mechanism.
2. Aggregation: A unified structure for includes and link flags.
3. Deduplication: A set-based filtering logic to ensure clean command lines.
4. Automatic Application: Seamless integration with the ToolchainOrchestrator.
With this foundation, AriaBuild is equipped to support the complex, multi-layered library architectures required by modern software development, paving the way for the v0.1.0 release.
Works cited
1. compiled.txt