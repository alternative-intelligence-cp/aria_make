Architectural Specification: Lightweight Dependency Scanning and Module Resolution for AriaBuild
1. Executive Summary and Strategic Context
The evolution of the Aria programming language ecosystem has reached a critical inflection point. As the language specification advances toward its v0.1.0 milestone, encompassing sophisticated features such as Twisted Balanced Binary (TBB) arithmetic, a hybrid memory model managing wild versus gc allocations, and a strict module system, the supporting infrastructure must mature concurrently. A pivotal component of this infrastructure is AriaBuild (internally designated aria_make), the deterministic build automation tool designed to replace legacy Makefiles with a declarative, whitespace-insensitive configuration format known as Aria Build Configuration (ABC).
While the high-level architecture of AriaBuild—specifically its Directed Acyclic Graph (DAG) engine and topological scheduler—has been established 1, a significant engineering gap remains in the mechanisms for dependency discovery. Modern build systems cannot rely solely on explicit configuration; they must interrogate source code to construct an accurate build graph. In the Aria context, dependencies are declared implicitly within source files via the use keyword (e.g., use std.io;).1
This report presents a comprehensive architectural specification and implementation strategy for a lightweight DependencyScanner and ModuleResolver subsystem. The primary objective is to extract these import directives from Aria source files with maximal throughput and minimal memory overhead, strictly avoiding the prohibitive latency associated with full Abstract Syntax Tree (AST) construction. This requirement is driven by the necessity to perform dependency discovery across massive monorepos—potentially containing tens of thousands of translation units—where the overhead of invoking the full ariac compiler frontend for every file during the graph construction phase would render the build system unresponsive.
The proposed solution leverages a bespoke, Finite-State-Machine (FSM) based lexical scanner implemented in C++17. This scanner is engineered to operate directly on memory-mapped source buffers, utilizing std::string_view to execute zero-copy tokenization. It is semantically aware of Aria's specific lexical structures—including single-line comments (//), double-quoted string literals ("), and back-tick template strings (`)—to prevent false positives, yet it remains grammatically agnostic to the complex logic of function bodies or variable declarations.
Coupled with the scanner is the ModuleResolver, a robust component responsible for translating extracted logical import paths (e.g., std.collections) into concrete, absolute file system paths (e.g., /usr/lib/aria/std/collections/mod.aria). This resolver implements the precise search path logic, aliasing rules, and file extension priorities defined in the Aria language specification.1 By integrating these components into the AriaBuild DependencyGraph, we enable the system to detect implicit edges, identify circular dependencies via Tri-Color Depth-First Search (DFS) 1, and enforce incremental compilation through timestamp analysis.
This document serves as the authoritative technical blueprint for implementing this subsystem, providing detailed C++17 code specifications, algorithmic analysis, and integration protocols.
________________
2. Theoretical Framework: The Dependency Discovery Problem
In the domain of compiler construction and build automation, dependency discovery represents a causal paradox: the build tool requires knowledge of the code's dependencies to determine the compilation order, yet definitively knowing the dependencies typically requires compiling the code. Resolving this paradox without incurring the cost of compilation is the central challenge addressed by this specification.
2.1 The Spectrum of Discovery Architectures
Approaches to dependency extraction exist on a spectrum of fidelity versus performance. An analysis of this spectrum justifies the architectural decision to employ a lightweight lexical scanner rather than alternative methods.
2.1.1 The Preprocessor Approach
Historically, C and C++ build systems relied on the preprocessor (e.g., gcc -M) to resolve #include directives. This method provides perfect accuracy because it executes the actual inclusion logic. However, it is computationally expensive because it requires reading every header file recursively and evaluating macros. For AriaBuild, relying on ariac -M (as implemented in the compiler driver 1) for every file during the initial graph construction phase would be too slow for large projects, as it invokes the heavy frontend logic.
2.1.2 The Full-Parse Approach
Modern ecosystems like Go or Rust often employ tools that parse the source code into an Abstract Syntax Tree (AST). This approach is robust against syntactic ambiguities. However, AST construction involves significant memory allocation. For a file with thousands of lines of code, allocating nodes for every function, statement, and expression merely to identify the use statements at the top of the file represents a massive waste of resources. The "Gap" identified in the AriaBuild architecture 1 specifically highlights the need to avoid this "parsing" overhead.
2.1.3 The Regex Approach
Simple build scripts frequently utilize Regular Expressions to identify import patterns. While fast to implement, regex engines are notoriously fragile when dealing with programming language syntax. A regex might easily misinterpret a use keyword inside a comment or a string literal as a real dependency.
* False Positive: print("Don't use std.io directly");
* False Positive: // use std.io;
Such errors corrupt the dependency graph, leading to either build failures or, worse, phantom dependencies that trigger unnecessary rebuilds.
2.1.4 The Lexical Scanning Approach (The Selected Architecture)
The proposed architecture occupies the optimal "sweet spot." It utilizes a specialized tokenizer (lexer) that understands the lexical "shape" of the language—comments, strings, keywords—but ignores its grammatical structure.
   * Mechanism: The scanner iterates through the character stream linearly ($O(N)$).
   * State Awareness: It maintains a minimal state (e.g., "Inside String," "Inside Comment").
   * Reactivity: It only reacts to the specific token use when in the valid CODE state.
   * Efficiency: It allocates no memory for AST nodes, symbol tables, or type information.
This approach guarantees accuracy comparable to a full parser regarding import detection while achieving throughput speeds closer to a regex engine.
2.2 The Aria Syntactic Constraint
The design of the DependencyScanner is strictly dictated by the lexical grammar of the Aria language as defined in the programming guide.1 The scanner must correctly identify use statements while navigating the "noise" of other language constructs.
2.2.1 Import Variations
The scanner must recognize the following syntactic forms of the use statement 1:
   1. Logical Import: use std.io; – The standard form importing a module path.
   2. Nested/Qualified Import: use std.collections.map; – Importing a specific submodule.
   3. Wildcard Import: use math.*; – Importing all symbols from a module.
   4. Selective Import: use std.collections.{array, map}; – Importing specific symbols. The dependency here is on the module std.collections.
   5. File Import: use "./utils.aria" as utils; – Importing a file path directly (string literal).
   6. Aliased Import: use std.io as my_io; – Renaming a module.
2.2.2 Syntactic Noise and Reserved Keywords
The robustness of the scanner depends on its ability to ignore use when it appears in non-structural contexts. Aria defines three primary constructs that "hide" code 1:
   * Single-line comments: Initiated by //. The scanner must ignore everything until the newline character. (Note: The spec does not explicitly detail block comments /*... */, but a robust scanner should ideally reserve capacity for them; however, strictly following the provided spec 1, we focus on //).
   * String literals: Enclosed in double quotes "...". The scanner must handle escape sequences (\") to avoid premature termination of the string state.
   * Template strings: Enclosed in backticks `...`. These support interpolation (&{expr}), but for dependency scanning, the content is irrelevant.
Crucially, use is a Reserved Keyword in Aria.1 This simplifies scanning significantly: a variable cannot be named use. Therefore, the scanner does not need complex lookahead to distinguish int use = 0; from use module; because the former is syntactically invalid Aria code. However, it does need to distinguish the substring "use" within other identifiers, such as user_id or pause. Boundary checking is essential.
2.3 Integration Context within AriaBuild
The DependencyScanner acts as the primary data ingestion engine for the Dependency Graph defined in the AriaBuild specification.1
   * Input: Raw source code from .aria files found via globbing expansion.
   * Output: A list of RawImport objects (logical or file paths).
   * Consumer: The ModuleResolver, which converts these into canonical std::filesystem::path objects.
   * Final Destination: The DependencyGraph, which creates edges ($A \rightarrow B$) based on these resolved paths.
This integration feeds the CycleDetector 1, allowing the build system to report errors like "Circular dependency detected: A -> B -> A" before any compilation occurs.
________________
3. Architectural Design: The Dependency Scanner
The DependencyScanner is architected as a high-performance, forward-only lexical analyzer. It avoids the overhead of the full aria::Lexer used in the compiler (which typically allocates Token objects for every lexeme) by implementing a specialized state machine focused solely on extraction.
3.1 Lexical State Machine Design
The core of the scanner is a Finite State Machine (FSM) that transitions between modes based on the character stream. The states are defined as follows:
   1. CODE: The default state. The scanner is processing active source code and looking for the use keyword.
   2. COMMENT: The scanner has encountered // and is consuming characters until a newline (\n).
   3. STRING: The scanner has encountered " and is consuming characters until the closing ", respecting escape sequences.
   4. TEMPLATE: The scanner has encountered ` and is consuming characters until the closing backtick.
   5. IMPORT_PENDING: The scanner has identified the keyword use in the CODE state and is now actively extracting the path characters until a semicolon ; is reached.
State Transition Logic
The FSM logic is rigorous to ensure no false positives or negatives:
   * State: CODE
   * Input / $\rightarrow$ Lookahead. If next char is /, transition to COMMENT.
   * Input " $\rightarrow$ Transition to STRING.
   * Input ` $\rightarrow$ Transition to TEMPLATE.
   * Input u $\rightarrow$ Check for keyword use.
   * If the sequence is use AND the following character is non-alphanumeric (space, tab, {), transition to IMPORT_PENDING.
   * Input [Alpha] $\rightarrow$ Skip identifier (to avoid matching user as use).
   * Other inputs $\rightarrow$ Continue.
   * State: COMMENT
   * Input \n $\rightarrow$ Transition to CODE.
   * Other inputs $\rightarrow$ Consume/Ignore.
   * State: STRING
   * Input \ $\rightarrow$ Consume next character (escape mechanism).
   * Input " $\rightarrow$ Transition to CODE.
   * Other inputs $\rightarrow$ Consume/Ignore.
   * State: TEMPLATE
   * Input ` $\rightarrow$ Transition to CODE.
   * Other inputs $\rightarrow$ Consume/Ignore.
   * State: IMPORT_PENDING
   * This is a sub-parser state. It accumulates characters into a buffer.
   * Input ; $\rightarrow$ Finalize import extraction, emit RawImport, transition to CODE.
   * Input " (if strictly file path) $\rightarrow$ Accumulate or handle as file import.
   * Input { or } $\rightarrow$ Handle selective import syntax constraints.
3.2 Zero-Copy Buffer Management (Optimization)
To achieve the "lightweight" requirement mandated by the prompt, the scanner minimizes memory allocation.
   * std::string_view: The scanner accepts the source file content as a std::string_view. This is a C++17 feature that provides a lightweight wrapper around a character array (pointer + length).
   * Implication: Passing the file content to the scanner involves copying only two 64-bit integers (the pointer and the size), regardless of the file size.
   * Token Extraction: When a use path is identified, the scanner can verify it. For the final output, std::strings are constructed only for the actual dependency paths, which are a tiny fraction of the total source text.
3.3 Handling Aria's Specific Constraints
The Aria language specification 1 notes that use is a reserved keyword. This simplifies the scanner significantly compared to languages where use might be a valid identifier. However, the scanner must still respect word boundaries.
   * Scenario: int user_count = 0;
   * Logic: The scanner sees u. It checks s, e. It matches "use". It checks the next character, r. Since r is alphanumeric, this is an identifier, not a keyword. The scanner ignores it.
   * Scenario: use std.io;
   * Logic: The scanner sees u, s, e. Next char is (space). Match confirmed. Transition to IMPORT_PENDING.
________________
4. Architectural Design: The Module Resolver
The DependencyScanner produces logical strings (e.g., std.io). The build system cannot check timestamps on logical strings. The ModuleResolver is the semantic counterpart that translates these strings into physical std::filesystem::path objects.
4.1 Resolution Strategy and Search Paths
The resolution logic implements the algorithm implied by Aria's module system 1 and build requirements.1
   1. Resolution of File Path Imports:
   * Input: use "./utils.aria"
   * Logic: Combine the directory of the current file being scanned with the relative path.
   * Example: Scanning src/main.aria. Import ./utils.aria. Result: src/utils.aria.
   * Canonicalization: Must resolve .. and . segments using std::filesystem::canonical or weak_canonical to ensure uniqueness in the dependency graph.
   2. Resolution of Logical Imports:
   * Input: use std.io
   * Logic: The resolver maintains a list of Search Paths (include directories).
   * Iteration: It checks each search path in order.
   * Path 1 (Project Root): Check src/std/io.aria.
   * Path 2 (Standard Lib): Check /usr/lib/aria/std/io.aria.
   * Structure Check (File vs. Module Directory): As seen in modern languages (Rust, etc.) and implied by Aria's structure 1, a module a.b can exist as:
   * a/b.aria (Direct file)
   * a/b/mod.aria (Directory module)
   * The resolver must probe for both. The precedence usually favors the direct file or follows a specific order defined by the language. For this implementation, we check for the file extension .aria first.
4.2 Caching for Performance
File system operations (stat, exists) are expensive, involving context switches to the kernel and disk I/O. In a large build, the module std.io might be imported by 500 different source files. Naively resolving it 500 times is inefficient.
   * Resolution Cache: The ModuleResolver maintains a thread-safe std::unordered_map<std::string, std::filesystem::path>.
   * Key: The combined key of (ImportString + ContextDirectory) or just ImportString for global modules.
   * Hit: If the mapping exists, return the path immediately ($O(1)$).
   * Miss: Perform the disk probe, store the result, and return.
4.3 Integration with AriaBuild Incremental Logic
The resolved paths feed directly into the Incremental Build logic described in.1 Once the resolver provides the physical path src/utils.aria, the build system uses std::filesystem::last_write_time to compare its timestamp against the target artifact. This link is vital: without accurate resolution, incremental builds are impossible because the system doesn't know which file's timestamp to check.
________________
5. C++17 Implementation Specification
This section provides the concrete C++17 class specifications. It leverages std::filesystem, std::string_view, and std::optional to ensure modern, safe, and expressive code.
5.1 Data Structures


C++




#include <string>
#include <string_view>
#include <vector>
#include <optional>
#include <filesystem>

namespace aria::build {

// Represents a raw import extracted from source text
struct RawImport {
   std::string path;      // The extracted path (e.g., "std.io" or "./utils.aria")
   bool is_file_path;     // True if it was a string literal import
   size_t line_number;    // For error reporting context
};

// Represents the location of the file being scanned
struct ScanContext {
   std::filesystem::path file_path;
   std::filesystem::path root_dir;
};

}

5.2 The DependencyScanner Class


C++




namespace aria::build {

class DependencyScanner {
public:
   DependencyScanner() = default;

   /**
    * Scans the provided source code for 'use' statements.
    * 
    * @param source The full content of the source file.
    * @return A vector of extracted imports.
    */
   std::vector<RawImport> scan(std::string_view source);

private:
   // Internal state management
   std::string_view source_;
   size_t pos_ = 0;
   size_t line_ = 1;

   // Helper methods for the FSM
   char peek() const;
   char advance();
   bool match(std::string_view keyword);
   
   // State handlers
   void skip_whitespace();
   void skip_single_line_comment();
   void skip_string_literal();
   void skip_template_string();
   
   // Extraction logic
   std::optional<RawImport> extract_import();
};

}

5.3 The ModuleResolver Class


C++




#include <unordered_map>
#include <mutex>

namespace aria::build {

class ModuleResolver {
public:
   ModuleResolver();

   // Configuration
   void add_search_path(const std::filesystem::path& path);

   /**
    * Resolves a raw import to a canonical physical path.
    * 
    * @param import The raw import extracted by the scanner.
    * @param context_dir The directory of the file containing the import.
    * @return The resolved path, or std::nullopt if not found.
    */
   std::optional<std::filesystem::path> resolve(const RawImport& import, 
                                                const std::filesystem::path& context_dir);

private:
   std::vector<std::filesystem::path> search_paths_;
   
   // Memoization cache: Logical Path -> Physical Path
   std::unordered_map<std::string, std::filesystem::path> cache_;
   std::mutex cache_mutex_; // Ensure thread safety for parallel scanning

   // Helper to probe filesystem
   std::optional<std::filesystem::path> probe(const std::filesystem::path& potential_path);
};

}

________________
6. Implementation Detail: The Scanning Logic
The following subsections detail the algorithmic implementation of the core scanning loops.
6.1 The Main Scanning Loop
The scan method serves as the driver. It iterates through the source_ view and dispatches to specific handlers based on the current character.


C++




// src/scan/dependency_scanner.cpp

std::vector<RawImport> DependencyScanner::scan(std::string_view source) {
   source_ = source;
   pos_ = 0;
   line_ = 1;
   std::vector<RawImport> imports;

   while (pos_ < source_.length()) {
       char c = peek();

       // 1. Comments: Check for start of single-line comment '//'
       if (c == '/') {
           if (pos_ + 1 < source_.length() && source_[pos_ + 1] == '/') {
               skip_single_line_comment();
               continue;
           }
       }

       // 2. String Literals: Check for '"'
       if (c == '"') {
           skip_string_literal();
           continue;
       }

       // 3. Template Strings: Check for '`'
       if (c == '`') {
           skip_template_string();
           continue;
       }

       // 4. Keywords: Check for 'use'
       // Optimization: Only check if char is 'u' to avoid function call overhead
       if (c == 'u') {
           if (match("use")) {
               auto imp = extract_import();
               if (imp) {
                   imports.push_back(*imp);
               }
               continue;
           }
       }

       // 5. Default: Advance
       advance();
   }

   return imports;
}

6.2 Handling Comments and Strings (The Noise Filter)
These methods ensure that keywords hidden inside comments or strings are ignored.


C++




void DependencyScanner::skip_single_line_comment() {
   // Consume '//'
   advance(); advance();
   
   // Consume until newline or EOF
   while (pos_ < source_.length()) {
       if (peek() == '\n') {
           advance(); // Consume newline, line counter updated in advance()
           break;
       }
       advance();
   }
}

void DependencyScanner::skip_string_literal() {
   advance(); // Consume opening quote
   
   while (pos_ < source_.length()) {
       char c = peek();
       if (c == '"') {
           advance(); // Consume closing quote
           break;
       }
       if (c == '\\') {
           advance(); // Consume backslash
           advance(); // Consume escaped character
       } else {
           advance();
       }
   }
}

void DependencyScanner::skip_template_string() {
   advance(); // Consume opening backtick
   
   while (pos_ < source_.length()) {
       char c = peek();
       if (c == '`') {
           advance(); // Consume closing backtick
           break;
       }
       // Note: Aria allows &{expr} interpolation. We strictly ignore
       // the contents, so we don't need to parse the expression.
       // A 'use' inside an interpolated string is still just a string.
       advance();
   }
}

6.3 Extracting the Import Path
This logic handles the IMPORT_PENDING state. It must parse complex paths like std.collections.* or "./file.aria".


C++




std::optional<RawImport> DependencyScanner::extract_import() {
   skip_whitespace();
   
   RawImport import;
   import.line_number = line_;
   import.is_file_path = false;
   
   char c = peek();
   
   // Case A: File Path Import (use "file.aria")
   if (c == '"') {
       import.is_file_path = true;
       advance(); // Skip open quote
       const size_t start = pos_;
       while (pos_ < source_.length() && peek()!= '"') {
           advance();
       }
       import.path = std::string(source_.substr(start, pos_ - start));
       if (peek() == '"') advance();
   }
   // Case B: Logical Import (use std.io)
   else {
       const size_t start = pos_;
       while (pos_ < source_.length()) {
           char curr = peek();
           // Allow: Alphanumeric, underscore, dot, star (wildcard)
           // Also allow { } , for selective imports
           if (std::isalnum(curr) |

| curr == '_' |
| curr == '.' |
| 
               curr == '*' |

| curr == '{' |
| curr == '}' |
| curr == ',') {
               advance();
           } else {
               break; // Delimiter found (semicolon, space, 'as')
           }
       }
       import.path = std::string(source_.substr(start, pos_ - start));
   }

   // Handle 'as alias' logic: we need to scan forward to the semicolon
   // to ensure we leave the scanner in a valid state.
   while (pos_ < source_.length() && peek()!= ';') {
       advance();
   }
   if (peek() == ';') advance(); // Consume semicolon

   if (import.path.empty()) return std::nullopt;
   return import;
}

________________
7. Implementation Detail: The Resolution Logic
The ModuleResolver translates the RawImport into a physical path.


C++




// src/scan/module_resolver.cpp

std::optional<std::filesystem::path> ModuleResolver::resolve(const RawImport& import, 
                                                            const std::filesystem::path& context_dir) {
   // 1. Handle Explicit File Imports
   if (import.is_file_path) {
       std::filesystem::path p(import.path);
       // Combine context directory with relative path
       std::filesystem::path resolved = context_dir / p;
       
       // Use std::filesystem to verify existence
       std::error_code ec;
       if (std::filesystem::exists(resolved, ec)) {
           return std::filesystem::canonical(resolved, ec);
       }
       return std::nullopt;
   }

   // 2. Handle Logical Imports
   {
       std::lock_guard<std::mutex> lock(cache_mutex_);
       if (cache_.count(import.path)) {
           return cache_.at(import.path);
       }
   }

   // Cleanup path: remove selective import parts for resolution
   // "std.collections.{a,b}" -> "std.collections"
   std::string clean_path = import.path;
   size_t brace = clean_path.find('{');
   if (brace!= std::string::npos) clean_path = clean_path.substr(0, brace);
   if (!clean_path.empty() && clean_path.back() == '.') clean_path.pop_back();

   // Convert dots to separators: std.io -> std/io
   std::replace(clean_path.begin(), clean_path.end(), '.', std::filesystem::path::preferred_separator);

   // Search Strategy
   for (const auto& root : search_paths_) {
       // Strategy A: Direct file (std/io.aria)
       auto candidate_file = root / clean_path;
       candidate_file.replace_extension(".aria");
       if (std::filesystem::exists(candidate_file)) {
           std::lock_guard<std::mutex> lock(cache_mutex_);
           cache_[import.path] = candidate_file;
           return candidate_file;
       }

       // Strategy B: Directory Module (std/io/mod.aria)
       auto candidate_mod = root / clean_path / "mod.aria";
       if (std::filesystem::exists(candidate_mod)) {
           std::lock_guard<std::mutex> lock(cache_mutex_);
           cache_[import.path] = candidate_mod;
           return candidate_mod;
       }
   }

   return std::nullopt;
}

________________
8. Integration with the AriaBuild Ecosystem
The scanner and resolver do not function in isolation; they are critical upstream components for the DependencyGraph defined in.1
8.1 Data Flow Pipeline
   1. Glob Expansion: AriaBuild identifies source files via glob patterns (src/**/*.aria).
   2. Parallel Scanning: For each identified file, a BuildTask is created. Using the thread pool 1, the file content is memory-mapped and passed to DependencyScanner::scan.
   3. Resolution: The output RawImport list is passed to the singleton ModuleResolver.
   4. Graph Population:
   * The source file is a Node.
   * Each resolved import path becomes a Node (if not already present).
   * Directed Edges are created: Source Node $\rightarrow$ Dependency Node.
   5. Cycle Analysis: As edges are added, the CycleDetector (implementing Tri-Color DFS 1) validates the topology. If main.aria depends on utils.aria, and utils.aria depends on main.aria, the build halts immediately with a cycle error.
8.2 Incremental Build Triggers
The paths resolved by ModuleResolver allow AriaBuild to perform its primary function: incremental builds.
   * Hash/Timestamp Check: For a target app, the build system checks the modification time of main.aria.
   * Transitive Check: It also recursively checks the modification time of every file resolved by the scanner (std.io, utils.aria).
   * Decision: If any resolved dependency is newer than the output artifact app.exe (or app.ll), the target is marked "Dirty" and recompiled.1
Without the ModuleResolver, AriaBuild would be blind to changes in imported modules, leading to "stale build" bugs where code changes don't propagate to the binary.
________________
9. Performance Analysis
The architectural choices made in this specification yield significant performance benefits compared to the alternatives.
9.1 Algorithmic Complexity
   * Scanning: $O(N)$ where $N$ is the number of characters in the source file. The single-pass FSM ensures each character is visited a constant number of times.
   * Resolution: $O(M \times P)$ where $M$ is the number of unique imports and $P$ is the number of search paths. Due to caching, the amortized complexity approaches $O(1)$ for repeated imports (e.g., standard library modules used in every file).
9.2 Memory Profiling
By using std::string_view for the source buffer, the scanner incurs effectively zero allocation overhead during the scan phase. It does not construct AST nodes, symbol tables, or intermediate tokens.
   * Legacy Parser Overhead: ~100 bytes per token (Token type, lexeme string, location info).
   * Lightweight Scanner Overhead: 0 bytes per token (skipped tokens are never instantiated).
9.3 Parallelism
The DependencyScanner is stateless and reentrant. It is perfectly suited for data parallelism. AriaBuild can map thousands of source files to its worker threads, scanning them concurrently without lock contention (as long as ModuleResolver cache access is synchronized).
________________
10. Conclusion and Recommendations
The DependencyScanner and ModuleResolver specified in this report address a fundamental requirement for the AriaBuild system: the ability to discover the dependency graph rapidly and accurately without invoking the heavy compiler frontend. By strictly adhering to C++17 standards and leveraging zero-copy idioms (string_view), the implementation ensures high throughput.
This architecture satisfies the unique syntactic constraints of the Aria language, specifically handling reserved keywords, TBB type noise, and various import formats. Furthermore, it integrates seamlessly with the existing CycleDetector and DAG engine, completing the toolchain necessary for hermetic and incremental builds.
Recommendations for Implementation Team
   1. Memory Mapping: Use mmap (POSIX) or CreateFileMapping (Windows) to load source files. This allows the OS to manage page caching and avoids copying file contents into user-space heap memory.
   2. Search Path Configuration: Ensure the ModuleResolver is initialized with paths from the aria.toml configuration and the ARIA_PATH environment variable to match the compiler's behavior.
   3. Testing: Implement a test suite containing "torture cases" involving use keywords inside strings, comments, and mixed with other identifiers to validate the FSM's robustness.
This specification provides a complete, robust, and performant foundation for the next generation of the Aria build infrastructure.
11. References (Integrated Context)
   * 1 Aria Language Guide: Provides the definitive syntax for use statements, comments (//), and string literals (" and `), as well as the list of reserved keywords which simplifies the keyword matching logic.
   * 1 AriaLS Architecture: Establishes the context of the thread pool and the performance limitations of the main compiler frontend ("parsing is blocking"), justifying the need for a separate, lightweight scanner.
   * 1 AriaBuild Specification: Defines the parent system (DAG engine, CycleDetector) that consumes the output of the scanner and resolver, and highlights the lack of standard library directory iteration functions, necessitating the C++ host implementation.
   * 1 Compiler Driver Analysis: Confirms that the ariac driver uses -M flags for dependency generation, which serves as the "source of truth" benchmark against which this lightweight scanner should be validated.
Works cited
   1. compiled.txt