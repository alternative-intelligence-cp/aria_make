Architectural Specification: FFI Linking Architecture Enhancement for AriaBuild
1. Introduction: The Systems Engineering Imperative for Modern Build Infrastructure
The evolution of software engineering practices has been inextricably linked to the maturation of build systems. From the imperative, shell-script-driven compilation of the early UNIX era to the complex, meta-build generators of the modern C++ ecosystem, the mechanism by which source code is transformed into executable artifacts defines the developer experience and the reliability of the resulting software. For the Aria programming language, currently positioned at version v0.0.7, the reliance on legacy tools or rudimentary compiler drivers presents a significant friction point in its trajectory toward becoming a viable systems programming language.1 The existing build infrastructure, AriaBuild (internally designated as aria_make), has successfully established a paradigm of "Configuration as Data," rejecting the fragile "Configuration as Code" models that often lead to non-deterministic build states.1 However, as the ecosystem matures, the requirement to interface with the vast legacy of C and C++ libraries—the Foreign Function Interface (FFI)—has become the critical path for adoption.
This report articulates a comprehensive architectural specification for the "FFI Linking Architecture Enhancement." This enhancement is not merely a feature addition; it is a structural evolution of the aria_make toolchain designed to bridge the gap between Aria’s high-level safety guarantees—such as Twisted Balanced Binary (TBB) arithmetic and hybrid memory models—and the raw, untyped reality of system linkers.1 The specification focuses on three critical vectors: extending the declarative Target schema to formally recognize external dependencies, implementing a polymorphic flag generation engine to transparently translate abstract definitions into the disparate syntaxes of Linux (ELF) and Windows (PE/COFF) linkers, and engineering a graph-theoretic solution for transitive library propagation.
1.1 The Context of Aria v0.0.7 and the LLVM Backend
Aria currently utilizes the LLVM infrastructure for code generation, compiling source files (.aria) into LLVM Intermediate Representation (.ll).1 Execution is primarily handled via the LLVM interpreter (lli), a strategy that facilitates rapid prototyping and debugging but masks the complexities of native linking.1 To transition from an interpreted experiment to a compiled systems language capable of producing standalone executables, AriaBuild must assume the role of a "Linker Driver." This role requires the build system to orchestrate not just the ariac compiler, but also the system linker (ld, link.exe, or lld), managing the intricate dance of symbol resolution, library search paths, and ABI compatibility.1
The architectural challenge is compounded by Aria's unique language features. The language introduces TBB types (e.g., tbb64) which carry "sticky error" semantics and specific bit-pattern sentinels (e.g., 0x80...00 for tbb8).1 When linking against C libraries, the build system must facilitate the correct generation of FFI boundaries where these types are marshaled. While the compiler handles the code generation for these boundaries, the build system must ensure that the correct static archives (.a, .lib) containing the C implementation of these interfaces are present and correctly ordered on the linker command line. A failure in the build system to propagate these dependencies results in "undefined reference" errors that are notoriously difficult for application developers to debug.
1.2 The Philosophy of Configuration as Data
AriaBuild distinguishes itself from tools like GNU Make by strictly adhering to a declarative philosophy. Makefiles often conflate dependency definitions with imperative shell commands, creating a brittle system where whitespace (tabs vs. spaces) can cause build failures.1 AriaBuild uses the Aria Build Configuration (ABC) format, a JSON-derivative syntax that is whitespace-insensitive and relies on structural delimiters (braces and brackets) to define scope.1
The proposed FFI enhancements must rigorously maintain this philosophy. The addition of library linking capabilities should not introduce imperative scripting elements into the aria.json file. Instead, it must extend the declarative schema, allowing developers to state what libraries are needed (e.g., libraries: ["ssl", "crypto"]) rather than how to link them (e.g., executing pkg-config or writing raw shell flags). The aria_make tool itself must bear the complexity of translating these declarations into the correct sequence of system calls, preserving the user's intent while abstracting the mechanism.
2. Architectural Analysis of the Existing AriaBuild Infrastructure
To engineer a robust FFI linking subsystem, one must first deconstruct the existing architecture of aria_make. This analysis identifies the integration points for the new functionality and highlights the current limitations that must be overcome.
2.1 The Aria Build Configuration (ABC) Parser
The entry point for the build system is the aria.json or build.aria file. The parser for this file is implemented in C++ (the host language of the build tool) and uses a custom lexical analyzer designed to align with Aria's own object literal syntax.1
* Lexical Structure: The parser treats all whitespace as token separators. Structure is defined by {} for objects, `` for lists, : for key-value separation, and , for element separation.1
* Identifier Parsing: Keys in the configuration do not require quotes if they are valid identifiers (alphanumeric and underscores, not starting with a digit), mirroring the src/frontend/lexer/token.cpp definitions of the Aria compiler.1
* Variable Resolution: The parser implements a substitution engine that resolves variables expressed as &{VAR}. This resolution follows a specific hierarchy: Local Scope (target-level), Global Scope (file-level), and Environment Scope (ENV.).1
Gap Analysis: The current schema validation logic allows for a flags field in the target definition, which is a list of strings passed directly to the compiler.1 This mechanism is insufficient for FFI for two reasons. First, it conflates compiler flags (e.g., -O3, -DDEBUG) with linker flags (e.g., -lcurl). Second, passing raw flags makes the configuration platform-dependent; a flag like -lpthread works on Linux but causes errors on Windows (MSVC), which expects pthread.lib or utilizes internal threading primitives. To solve this, the parser must be updated to recognize semantic fields for libraries, separate from raw flags.
2.2 The Dependency Graph Engine (DAG)
The core logic of AriaBuild revolves around a Directed Acyclic Graph (DAG), where nodes represent build entities (source files, intermediate artifacts, and targets) and edges represent dependencies.1
* Graph Construction: The build system parses the depends_on field in the target schema to build the edges of the graph. It uses Kahn’s Algorithm for topological sorting to derive a linear execution schedule.1
* Implicit Dependencies: The engine also parses source code for use statements (e.g., use std.io;) to create implicit edges between source files.1
* Cycle Detection: The system performs Depth First Search (DFS) to identify and report circular dependencies, which are illegal in the build graph.1
Gap Analysis: The current DAG implementation propagates ordering but does not propagate attributes. When Target A depends on Target B, the build scheduler ensures B finishes before A starts. However, it does not currently aggregate the metadata from B—specifically, its requirement to link against external binary libraries—and pass it to the linker step of A. This "metadata isolation" prevents effective FFI management in multi-module projects. If std.net links against libcurl, any application depending on std.net must also link against libcurl, but the current graph does not automate this.
2.3 The Toolchain Orchestrator
The ToolchainOrchestrator class (conceptually defined in the architecture) acts as the translation layer between the abstract target definition and the concrete OS processes.1
* Current Responsibilities: It maps the output field to the -o flag and converts depends_on entries into -I (include) paths for the ariac compiler.1 It also handles the invocation of lli for binary execution.1
* Globbing and Determinism: The orchestrator utilizes a C++17 std::filesystem implementation to expand glob patterns (e.g., src/**/*.aria). Crucially, it enforces strict alphabetical sorting of these files to ensure deterministic builds, as the order of linking matters for symbol resolution.1
Gap Analysis: There is a "Linking Vacuum" in the current orchestrator. It assumes that compilation via ariac is sufficient. It lacks a dedicated "Linker Driver" phase that is aware of the host OS semantics (ELF vs. PE/COFF). The implementation of construct_link_cmd is essentially missing or primitive, relying on the compiler driver to handle everything, which fails when complex external library paths are involved.
3. Theoretical Framework of Systems Linking
Implementing a cross-platform linker driver requires a rigorous understanding of the underlying linking models, which diverge significantly between Unix-like systems (Linux, macOS) and Windows. A naive string concatenation approach will fail to produce portable builds.
3.1 The Unix Linking Model (ELF)
On Linux and macOS, linking is typically handled by ld (or driven via gcc/clang). The format is Executable and Linkable Format (ELF) on Linux and Mach-O on macOS.
* Library Search Paths (-L): These flags specify directories where the linker looks for archives. Order matters; if two directories contain libfoo.so, the one specified first takes precedence.
* Library Names (-l): The -lfoo flag instructs the linker to search for libfoo.so (dynamic) or libfoo.a (static). The lib prefix and file extension are implicit.
* Order Sensitivity: This is a critical constraint. The GNU linker processes files from left to right. It maintains a list of undefined symbols. If main.o references a symbol in libutils.a, then main.o must appear before -lutils on the command line. If -lutils appears first, the linker discards it as "unused" before encountering the reference in main.o, leading to an "Undefined Reference" error.
* RPATH/RUNPATH: For dynamic libraries located in non-standard directories (e.g., vendor libraries bundled with the application), the binary must contain an RPATH entry to tell the dynamic loader (ld.so) where to find them at runtime.
3.2 The Windows Linking Model (PE/COFF)
Windows uses the Portable Executable (PE) format, and the linking semantics differ fundamentally.
* Library Paths (/LIBPATH:): Equivalent to -L.
* Library Files: There is no direct -l flag. Libraries are passed as standard arguments (e.g., kernel32.lib). The linker distinguishes them by file extension or file signature.
* Import Libraries: Linking against a DLL requires linking against a corresponding .lib import library. The linker does not link directly against the .dll.
* Symbol Resolution: Windows linking is generally less order-sensitive regarding symbol resolution compared to the traditional one-pass GNU ld, but priority rules still apply.
* Runtime Dependency: The OS loader searches for DLLs in the application directory and the system PATH. There is no direct equivalent to RPATH embedded in the binary in the same way as ELF, making dependency placement (side-by-side assembly) critical.
* CRT Conflict: A pervasive issue in Windows C++ development is the conflict between the Static C Runtime (/MT) and the Dynamic C Runtime (/MD). Mixing object files linked against different CRTs causes linker error LNK2038.
3.3 The Transitive Dependency Problem
In a modular architecture, dependencies form a tree.
* Scenario: App imports Middleware. Middleware imports LowLevelLib. LowLevelLib uses FFI to link libdriver.so.
* Static Linking Requirement: If Middleware and LowLevelLib are compiled as static archives (.a / .lib), they are merely collections of object files. They do not "link" against libdriver.so in the sense of embedding it; they only reference its symbols.
* The Responsibility Shift: When linking the final App executable, the linker must be explicitly told to link libdriver.so. The author of App should not need to know this implementation detail of LowLevelLib.
* Solution: The build system must traverse the dependency graph, collect the linking requirements of all transitive dependencies, and aggregate them into the final linker command for the executable.
4. Schema Extension Specification
To support these requirements, we extend the Target struct in the ABC schema. These new fields serve as the "Source of Truth" for the ToolchainOrchestrator and decouple the user's intent from the underlying toolchain flags.1
4.1 Extended Target Schema
The aria.json schema is augmented with two optional list fields: libraries and library_paths.


C++




// Conceptual C++ definition of the Target struct extension within BuildContext
struct Target {
   //... existing fields (name, type, sources, depends_on, output, flags)...

   /**
    * @brief Abstract names of external libraries to link against.
    *
    * Examples: ["curl", "ssl", "crypto", "pthread"]
    *
    * The build system transforms these into platform-specific flags:
    * - Linux: "-lcurl"
    * - Windows: "curl.lib" (or "libcurl.lib" depending on convention)
    */
   std::vector<std::string> libraries;

   /**
    * @brief Filesystem paths to search for the above libraries.
    *
    * Examples: ["/usr/local/lib", "C:/libs/openssl/lib"]
    *
    * The build system transforms these into:
    * - Linux: "-L/usr/local/lib"
    * - Windows: "/LIBPATH:C:/libs/openssl/lib"
    */
   std::vector<std::string> library_paths;
};

4.2 ABC Syntax Example
In the aria.json file, these fields are exposed as standard arrays. The syntax remains whitespace-insensitive and supports variable interpolation.1


JavaScript




// build.aria
{
   project: { name: "HttpServer", version: "1.0.0" },
   
   variables: {
       // Platform-agnostic variable for lib path using Environment Scope
       // On Windows this might resolve to a different path via ENV
       openssl_path: "&{ENV.OPENSSL_ROOT}/lib" 
   },

   targets: [
       {
           name: "net_module",
           type: "library",
           sources: ["src/net/**/*.aria"],
           
           // FFI Dependencies
           // Note: We do not write "-lssl" or "ssleay32.lib"
           // We write the abstract name "ssl"
           libraries: ["ssl", "crypto", "z"],
           
           // Path injection using variable interpolation
           library_paths: ["&{openssl_path}", "vendor/lib"]
       },
       {
           name: "main_app",
           type: "binary",
           sources: ["src/main.aria"],
           
           // Dependency on internal target
           // System must propagate "ssl" and "crypto" from net_module to here
           depends_on: ["net_module"], 
           
           output: "bin/server"
       }
   ]
}

4.3 Validation Logic
The ConfigParser must enforce the following validation rules during the initial load phase:
1. Type Safety: libraries and library_paths must be lists of strings.
2. Path Existence: While checking for the existence of absolute system paths (like /usr/lib) is optional (as they might exist on the build server but not the dev machine), checking for relative paths within the project (vendor/lib) should emit a warning if the directory is missing.
3. Forbidden Characters: To prevent shell injection attacks, library names should be validated against a strict whitelist (alphanumeric, underscores, hyphens, and periods). This is critical because library names are often passed to shell execution primitives.
5. Implementation Strategy: The Transitive Dependency Engine
The most complex algorithmic challenge is the correct propagation of dependencies. This logic resides in the DependencyGraph class and operates after the topological sort is complete.
5.1 The Transitive Closure Algorithm
When the ToolchainOrchestrator prepares to build a target $T$, it must compute the Linker Context, which is the union of $T$'s requirements and the requirements of the transitive closure of $T$'s dependencies.
Algorithm: Recursive Linker Context Collection
The traversal strategy must be Depth-First (DFS) to respect the linking order required by GNU ld.


C++




struct LinkerContext {
   std::vector<std::string> ordered_libraries;
   std::vector<std::string> search_paths;
   std::set<std::string> visited_nodes; // Cycle detection for the traversal
};

void collect_linker_context(const Target& current, LinkerContext& ctx, const Graph& graph) {
   // 1. Cycle Detection (Safety check, though graph is already DAG)
   if (ctx.visited_nodes.count(current.name)) return;
   ctx.visited_nodes.insert(current.name);

   // 2. Post-Order Traversal (Depth-First)
   // We visit dependencies first. This is crucial for GNU ld.
   // The safest ordering for static linking is:
   // [App Objects][Lib A]
   // Therefore, we recurse into dependencies BEFORE processing the current node's libs.
   
   // Iterate depends_on in reverse order to maintain stack discipline if necessary,
   // but typically standard iteration works if the graph construction was correct.
   for (const std::string& dep_name : current.depends_on) {
       const Target& dep_target = graph.get_target(dep_name);
       collect_linker_context(dep_target, ctx, graph);
   }

   // 3. Aggregate Attributes
   // Append library paths (Deduplication is important here)
   for (const auto& path : current.library_paths) {
       if (std::find(ctx.search_paths.begin(), ctx.search_paths.end(), path) == ctx.search_paths.end()) {
           ctx.search_paths.push_back(path);
       }
   }

   // Append libraries
   // Note: Deduplication of libraries is tricky. 
   // Sometimes you need -lfoo -lbar -lfoo to resolve circular symbols.
   // However, for standard DAGs, simple appending works.
   for (const auto& lib : current.libraries) {
       ctx.ordered_libraries.push_back(lib);
   }
}

5.2 Deduplication Strategy
* Paths: library_paths should be strictly deduplicated. Passing -L/usr/lib twenty times bloats the command line and adds minor overhead. The implementation should use a std::vector combined with std::find (linear search is faster than std::set overhead for small N) to maintain a unique list of paths.
* Libraries: Deduplication of library names is generally safe unless there are circular dependencies between static libraries (e.g., LibA needs LibB, LibB needs LibA).
   * Linux Strategy: Use --start-group and --end-group (or -( and -)) to wrap the library list. This allows the linker to cycle through the archives to resolve symbols repeatedly, eliminating the need for manual repetition or strict topological ordering.
   * Windows Strategy: The MSVC linker handles circular dependencies between .lib files automatically in most cases without explicit grouping flags.
5.3 Determinism Enforcement
As noted in the source material regarding globbing 1, determinism is paramount.
* Sorting: While glob results are sorted alphabetically, the depends_on list defines a semantic order. The collection algorithm respects the developer's declared order in depends_on (and the depth-first traversal), ensuring that the linker command line is deterministic given the same configuration file. It does not alphabetize the final library list, as that would break linking order (e.g., -lssl must come before -lcrypto).
6. Platform-Specific Flag Generation (The Polymer Engine)
The ToolchainOrchestrator implements a "Polymer Engine"—a logic unit that changes shape based on the host OS. This engine takes the abstract LinkerContext and serializes it into a concrete command string.
6.1 Platform Detection
The build system detects the platform at runtime (or compile-time of the build tool) using preprocessor macros or std::filesystem traits.


C++




enum class TargetPlatform { Linux, Windows, MacOS, Unknown };

TargetPlatform detect_platform() {
   #ifdef _WIN32
       return TargetPlatform::Windows;
   #elif defined(__APPLE__)
       return TargetPlatform::MacOS;
   #elif defined(__linux__)
       return TargetPlatform::Linux;
   #else
       return TargetPlatform::Unknown;
   #endif
}

6.2 Linux/Unix Implementation (ELF)
On Linux, we utilize the GCC/Clang driver syntax, which delegates to ld. The ToolchainOrchestrator must construct the following flags:
* Library Path Prefix: -L
* Library File Prefix: -l
* Library File Suffix: None (implicit)
Special Consideration: RPATH
To support the execution of binaries linked against shared libraries in non-standard locations (e.g., dist/lib), the orchestrator automatically injects RPATH flags.
* Flag: -Wl,-rpath,$ORIGIN/../lib
* Logic: This makes the binary look for DLLs relative to its own location ($ORIGIN), creating portable "xcopy" installable packages.
Code Logic:


C++




std::string generate_linux_flags(const LinkerContext& ctx) {
   std::stringstream ss;
   
   // 1. Paths
   for (const auto& path : ctx.search_paths) {
       // Quote paths to handle spaces: -L"/path/to lib"
       ss << "-L\"" << path << "\" ";
   }

   // 2. RPATH injection for local development
   ss << "-Wl,-rpath,'$ORIGIN/lib' ";

   // 3. Libraries (using group for cycle safety)
   ss << "-Wl,--start-group ";
   for (const auto& lib : ctx.ordered_libraries) {
       ss << "-l" << lib << " ";
   }
   ss << "-Wl,--end-group ";

   return ss.str();
}

6.3 Windows Implementation (PE/COFF)
On Windows, we target link.exe (MSVC) or lld-link (LLVM). The syntax is drastically different.
* Library Path Prefix: /LIBPATH:
* Library File Prefix: None (Passed as filename)
* Library File Suffix: .lib (Must be appended if missing)
Special Consideration: The CRT Conflict
Windows libraries are compiled against specific versions of the C Runtime (Static /MT or Dynamic /MD). Mixing them causes linker error LNK2038.
* Policy: aria_make defaults to static linking (/MT) for release builds to produce standalone executables. The orchestrator must ensure that any system libraries linked are compatible. If the developer needs dynamic linking, they must specify this in the target flags, and the orchestrator should ideally validate this against the library configurations (though deeper binary inspection is out of scope for v0.1.0).
Code Logic:


C++




std::string generate_windows_flags(const LinkerContext& ctx) {
   std::stringstream ss;
   
   // 1. Paths
   for (const auto& path : ctx.search_paths) {
       // Windows paths might contain backslashes; sanitize or quote.
       ss << "/LIBPATH:\"" << path << "\" ";
   }

   // 2. Libraries
   for (const auto& lib : ctx.ordered_libraries) {
       std::string lib_name = lib;
       // Auto-append extension if missing
       if (lib_name.find(".lib") == std::string::npos) {
           lib_name += ".lib";
       }
       ss << "\"" << lib_name << "\" ";
   }

   // 3. Standard Windows System Libraries
   // These are often implicitly needed for any non-trivial application
   ss << "kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ";

   return ss.str();
}

7. Integration with Aria Standard Library (std.net)
The FFI architecture is not theoretical; it is driven by the immediate need to support std.net (likely wrapping libcurl or native socket APIs).1 The Aria Standard Library often acts as a wrapper around C system calls or libraries.
7.1 The Wrapper Pattern
Aria modules that wrap C libraries will define a target in the aria.json of the standard library distribution. This utilizes the new FFI features to encapsulate the dependency.


JavaScript




// std/build.aria
{
   targets: [
       {
           name: "std_net",
           type: "library",
           sources: ["net/**/*.aria"],
           // Links against the platform's socket libraries
           libraries: 
       }
   ]
}

* Variable Injection: The &{ENV.OS_NET_LIB} variable is crucial.
   * On Windows, the aria_make bootstrapper sets this to ws2_32 (Winsock).
   * On Linux, it might be empty (if sockets are in libc) or pthread depending on the implementation.
* Automatic Propagation: When a user writes depends_on: ["std_net"] in their application, the Transitive Dependency Engine ensures that ws2_32.lib is linked into their final executable on Windows, transparently enabling networking support.
7.2 Safety Considerations: TBB and Wild Pointers
Aria's memory model distinguishes between gc (garbage collected) and wild (manual) memory.1 When linking against FFI libraries, almost all interactions will involve wild pointers.
* TBB Safety: The Twisted Balanced Binary (TBB) types used in Aria (e.g., tbb64) perform specific arithmetic with error saturation. When passing these values to C functions (e.g., setsockopt timeouts), the bindings must ensure the bit representations are compatible or perform marshalling. The extern keyword in Aria facilitates this, but the linker must find the symbol implementation.
* Pinning: If Aria passes a GC-managed buffer to a C library (e.g., curl_easy_setopt writing to a string), that buffer must be pinned. The build system does not enforce this runtime behavior, but it must link the runtime components that support pinning.
8. Security and Path Sanitization
The injection of external paths into the linker command line presents a security surface, particularly regarding "DLL Hijacking" or "Search Path Poisoning."
8.1 Path Sanitization
The orchestrator must sanitize all paths provided in library_paths.
* Relative Path Lockdown: Paths must be resolved relative to the project root. The orchestrator should reject paths attempting to traverse upwards (e.g., ../../../../usr/bin) unless they resolve to absolute system paths known to be safe.
* Injection Prevention: Library names must be sanitized to prevent argument injection. If a malicious library name foo; rm -rf / were passed to a shell-executing build tool, it could be catastrophic.
   * Mitigation: aria_make uses std::filesystem and direct process spawning (e.g., execvp or CreateProcess) rather than invoking a shell (system()). Arguments are passed as an array of strings, not a concatenated command string, rendering shell injection impossible. The sorting of glob results 1 ensures that even if file names are malicious, the order of processing is deterministic and observable.
9. Testing and Verification Strategy
To ensure the robustness of the FFI subsystem, a three-tiered testing strategy is defined.
9.1 Unit Testing (Flag Generation)
Isolate the generate_linux_flags and generate_windows_flags functions. Feed them a mock LinkerContext and assert that the output string exactly matches the expected linker syntax.
* Test Case: libraries=["curl"], paths=["/opt/lib"] -> Linux: -L"/opt/lib" -Wl,--start-group -lcurl -Wl,--end-group
9.2 Integration Testing (Mock Libraries)
Create a test fixture with dummy C static libraries.
1. Create libtest.c -> compile to libtest.a / test.lib.
2. Create app.aria that declares extern func test_func();.
3. Create build.aria targeting app with libraries: ["test"].
4. Run aria_make.
5. Verify the binary links and runs successfully.
9.3 Cross-Platform CI
The build system itself must be built and tested on GitHub Actions runners for Ubuntu-latest and Windows-latest. This ensures that the std::filesystem behavior and path separator logic (/ vs \) function correctly in the wild.
10. Conclusion
The architecture defined in this report transforms aria_make from a simple compiler driver into a production-grade build system capable of managing complex, multi-language dependencies. By introducing explicit libraries and library_paths to the Target schema and backing them with a transitive dependency engine and a polymorphic flag generator, we solve the "Linker Hell" problem for Aria developers.
This design respects the "Configuration as Data" philosophy 1 by keeping the configuration declarative and readable, while burying the complexity of platform ABIs deep within the C++ implementation of the toolchain. It provides the necessary foundation for the Aria ecosystem to integrate with the world's software infrastructure, paving the way for high-performance networking, graphics, and cryptographic applications. The enhancement ensures that whether on Linux or Windows, the developer experience remains consistent, deterministic, and safe.
11. Appendix: C++ Implementation Snippets
11.1 Linker Command Construction (ToolchainOrchestrator.cpp)


C++




std::vector<std::string> ToolchainOrchestrator::construct_link_cmd(
   const Target& target, 
   const std::vector<std::string>& object_files,
   const LinkerContext& ctx
) {
   std::vector<std::string> cmd;
   
   // Select Linker
   if (platform == TargetPlatform::Windows) {
       cmd.push_back("link.exe");
       cmd.push_back("/NOLOGO");
       cmd.push_back("/OUT:" + target.output);
   } else {
       cmd.push_back("clang"); // Use driver to handle CRT
       cmd.push_back("-o");
       cmd.push_back(target.output);
   }

   // Input Objects
   for (const auto& obj : object_files) {
       cmd.push_back(obj);
   }

   // Library Paths
   for (const auto& path : ctx.search_paths) {
       if (platform == TargetPlatform::Windows) {
           cmd.push_back("/LIBPATH:" + path);
       } else {
           cmd.push_back("-L" + path);
       }
   }

   // Libraries
   if (platform == TargetPlatform::Linux) {
       cmd.push_back("-Wl,--start-group");
   }
   
   for (const auto& lib : ctx.ordered_libraries) {
       if (platform == TargetPlatform::Windows) {
           // Check extension
           std::string lib_arg = lib;
           if (lib_arg.find(".") == std::string::npos) lib_arg += ".lib";
           cmd.push_back(lib_arg);
       } else {
           cmd.push_back("-l" + lib);
       }
   }

   if (platform == TargetPlatform::Linux) {
       cmd.push_back("-Wl,--end-group");
   }

   return cmd;
}

11.2 Target Struct Extension (Target.h)


C++




struct Target {
   std::string name;
   TargetType type;
   std::vector<std::string> sources;
   std::vector<std::string> depends_on;
   std::string output;
   
   // FFI Extensions
   std::vector<std::string> libraries;      // e.g. "curl", "z"
   std::vector<std::string> library_paths;  // e.g. "/usr/local/lib"
   
   // Internal flags
   std::vector<std::string> flags;
};

Works cited
1. compiled.txt