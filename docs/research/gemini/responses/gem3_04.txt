Architectural Specification for the Integration of Foreign Function Interface (FFI) Linking into the AriaBuild Toolchain
1. Executive Summary and Strategic Architectural Context
The progression of the Aria programming language ecosystem towards its version 0.1.0 milestone represents a definitive shift from theoretical language design to practical systems engineering. As the language specification hardens—incorporating advanced primitives such as Twisted Balanced Binary (TBB) arithmetic, optional types with strict nullity semantics, and a highly encapsulated module system—the supporting build infrastructure must evolve to accommodate the complexities of modern software interoperability. The current build system, AriaBuild (internally referenced as aria_make), operates on a "Configuration as Data" philosophy, utilizing a declarative, whitespace-insensitive format (Aria Build Configuration or ABC) to define build targets.1 While this architecture has proven robust for native compilation units, utilizing the ariac compiler and LLVM interpreter (lli), it currently lacks a formalized, rigorous mechanism for orchestrating the linking of external binary dependencies via the Foreign Function Interface (FFI).
The requirement to support FFI linking is not merely a feature request; it is a structural imperative driven by the "Gemini Work Package," which necessitates the static integration of complex third-party libraries such as libcurl to underpin the emerging package manager infrastructure.1 Without first-class support for linking against established C/C++ artifacts, Aria remains an isolated ecosystem, incapable of leveraging the vast repository of existing system libraries. The absence of a managed linking strategy forces developers into "build script hell," wrapping ariac invocations in fragile shell scripts to manually inject linker flags—a practice that violates the hermetic, reproducible build goals of the project.
This architectural specification presents a comprehensive, expert-level design for enhancing the ToolchainOrchestrator subsystem and the fundamental Node data structure within AriaBuild. The objective is to introduce native, cross-platform support for FFI linking by extending the dependency graph to comprehend external binary artifacts. This involves a precise augmentation of the Node struct to include libraries and library_paths vectors, and a complete re-engineering of the ToolchainOrchestrator::construct_link_cmd method.
The proposed solution addresses the fundamental divergence between the ELF (Executable and Linkable Format) linking semantics of Linux/Unix systems and the PE/COFF (Portable Executable / Common Object File Format) semantics of the Windows ecosystem. By abstracting these differences behind a unified declarative interface, AriaBuild will empower developers to define external dependencies simply—e.g., libraries: ["curl"]—while the orchestrator handles the complex flag generation, path normalization, and ordering requirements specific to the host toolchain (GNU ld, LLVM lld, or MSVC link.exe). This report details the theoretical underpinnings, data structure modifications, implementation logic, and verification strategies required to deliver this critical capability, ensuring that AriaBuild matures into a toolchain capable of orchestrating hybrid, high-performance systems applications.
2. Theoretical Framework: The Mechanics of System Linking
To effectively architect a solution for FFI linking, one must first deconstruct the role of the linker in a compiled language toolchain and the specific challenges posed by cross-platform support. Linking is the final phase of the compilation pipeline, where independent object files—generated by the compiler from source units—are combined into a single executable image or shared library. This process involves symbol resolution (matching function calls to their definitions) and address relocation (adjusting code to run at specific memory addresses).
2.1 The "Assembly Bottleneck" and the Shift to Object Orchestration
Recent architectural audits of the Aria compiler driver (ariac) identified a critical inefficiency termed the "Assembly Bottleneck".1 Historically, the pipeline generated textual assembly files (.s) which were then passed to an external assembler. The modernization of the toolchain moves towards direct object file emission, bypassing the textual representation to generate machine code artifacts (.o or .obj) directly from LLVM IR.
This shift places the ToolchainOrchestrator in a pivotal role. It is no longer just invoking a compiler; it is orchestrating a graph of binary artifacts. When FFI is introduced, this graph expands to include "System Nodes"—artifacts that are not built by AriaBuild but are assumed to exist on the host system (e.g., libssl.so or kernel32.lib). The linker must be instructed not only where to find these artifacts but how to prioritize them against internal symbols to avoid collision or undefined reference errors.
2.2 The Thundering Herd: Linker Resource Contention
Linking is inherently resource-intensive. Unlike compilation, which is "embarrassingly parallel" and scalable across CPU cores (compiling A.aria and B.aria are independent events), linking is a synchronization point. It requires a global view of the program. Modern linkers like lld (the LLVM Linker) are highly optimized, but they still consume significant memory to build symbol tables and perform Link Time Optimization (LTO).
The "Thundering Herd" problem, discussed in the context of the build scheduler 1, is exacerbated by FFI linking. If the build system attempts to link multiple heavy executables (e.g., the main application and several integration test suites) simultaneously, and each links against a massive static library like libcurl or libllvm, the system risks Out-Of-Memory (OOM) thrashing. The enhanced ToolchainOrchestrator must therefore be efficient in its command construction, minimizing overhead before handing control to the heavy linker process, and potentially exposing hooks for the scheduler to limit concurrent link jobs.
2.3 Platform Divergence: ELF vs. PE/COFF
The central complexity in this engineering task is the semantic chasm between Linux (ELF) and Windows (COFF) linking models. A naive implementation that simply concatenates strings will fail to produce portable builds.
2.3.1 The Linux/Unix Model (GNU ld / LLVM lld)
The Linux linking model is defined by the System V ABI and standardized tools like GNU ld.
* Flag Syntax: Uses hyphenated flags. -L/path/to/lib adds a search directory. -lfoo searches for libfoo.so or libfoo.a.2
* Ordering Semantics: The most critical aspect of ELF linking is order sensitivity. The linker processes files from left to right. It maintains a list of "undefined symbols." When it encounters an object file (main.o), it adds symbols referenced but not defined (e.g., curl_easy_init) to this list. When it subsequently encounters a library (-lcurl), it checks if the library resolves any undefined symbols. If it does, it pulls in the necessary object code. Crucially, if the library appears before the object file that needs it, the linker will discard the library's symbols as "unused" before it sees the requirement, resulting in an "undefined reference" error.3
* Name Decoration: The -l flag assumes a lib prefix and a .so or .a extension. -lssl implies looking for libssl.so.
2.3.2 The Windows Model (MSVC link.exe / lld-link)
The Windows model differs in almost every respect.
* Flag Syntax: Uses forward slashes (conventionally) or hyphens. /LIBPATH:C:\Path is the equivalent of -L.
* Library Specification: There is no direct equivalent to -l. Libraries are passed as standard file arguments (e.g., kernel32.lib). The concept of a "search path" applies to finding these files.5
* Import Libraries: Linking against a DLL requires linking against a corresponding .lib import library. The linker does not link against .dll files directly.6
* Ordering: While newer linkers are more flexible, Windows linkers traditionally prioritized explicitly listed libraries over default system libraries. The /LIBPATH directive overrides the %LIB% environment variable.5
The ToolchainOrchestrator must act as a "Translation Layer," taking a platform-agnostic definition of a dependency (e.g., name: "curl", path: "/opt/lib") and generating the syntactically correct flag sequence for the active target platform.
3. Data Structure Architecture: Enhancing the Node Schema
The foundation of the AriaBuild system is the Dependency Graph, a Directed Acyclic Graph (DAG) where nodes represent build entities (source files, objects, binaries). To support FFI, the schema of these nodes must be enriched. Currently, a Node effectively represents a compilation unit. We must extend it to represent a "Linkage Unit."
3.1 The Augmented Node Structure
The Node class, conceptually defined in dependency_graph.h, requires two new data members to store FFI configuration. These members must be std::vector<std::string> containers to maintain the order of dependencies—a critical requirement for static linking as established in Section 2.3.1.
Architectural Definition:


C++




namespace aria {
namespace graph {

/**
* @class Node
* @brief Represents a discrete entity in the build dependency graph.
* 
* A Node abstracts a build artifact (e.g., an executable, a library, or an object file).
* In the context of FFI, the Node acts as the container for external linkage requirements,
* holding the metadata necessary to construct linker command lines without embedding
* platform-specific syntax directly into the graph logic.
*/
class Node {
public:
   //... existing members (name, type, source_files, output_file, dependencies)...

   /**
    * @brief External Library Search Paths.
    * 
    * A vector of filesystem paths where the linker should look for external binary artifacts.
    * These strings are raw paths (e.g., "vendor/lib", "/usr/local/opt/openssl/lib").
    * The ToolchainOrchestrator is responsible for sanitizing these paths and converting
    * them into the appropriate flag format (-L or /LIBPATH).
    * 
    * Design Note: Stored as a vector to preserve search precedence. Linkers search directories
    * in the order specified.
    */
   std::vector<std::string> library_paths;

   /**
    * @brief External Library Names.
    * 
    * A vector of abstract library identifiers (e.g., "curl", "m", "z", "user32").
    * These identifiers are decoupled from their physical filenames. The Orchestrator
    * handles the decoration logic:
    *   - Linux: "curl" -> "-lcurl" (resolves to libcurl.so/a)
    *   - Windows: "curl" -> "curl.lib"
    * 
    * Support for specific filenames: If an entry contains a file extension (e.g., "libfoo.a"),
    * the Orchestrator should treat it as a direct file input rather than a search flag.
    */
   std::vector<std::string> libraries;

   //... methods...
   
   void add_library(const std::string& lib) {
       libraries.push_back(lib);
   }

   void add_library_path(const std::string& path) {
       library_paths.push_back(path);
   }
};

} // namespace graph
} // namespace aria

3.2 Schema Integration with Aria Build Configuration (ABC)
The Node struct is hydrated by parsing the build.aria file. The ABC format, being a JSON-derivative optimized for readability 1, must be updated to support these new fields. The parser logic (leveraging the Aria frontend lexer) needs to map the JSON arrays libraries and library_paths directly into the Node instance.
Example ABC Configuration:


JavaScript




// build.aria
targets: [
   {
       name: "http_service",
       type: "binary",
       sources: ["src/main.aria"],
       depends_on: ["std.net.http"],
       
       // New FFI Configuration
       // Abstract names ensure the config is portable
       libraries: ["curl", "ssl", "crypto"],
       
       // Paths can use variables &{...} for environment adaptation
       library_paths:
   }
]

3.3 Transitive Dependency Resolution Strategy
A major architectural consideration is the handling of transitive system dependencies. If http_service depends on std.net.http (an internal Aria library), and std.net.http wraps libcurl, does http_service need to explicitly link libcurl?
* Dynamic Linking: Generally, no. The std.net.http shared object would record its dependency on libcurl.so via DT_NEEDED tags in ELF.7
* Static Linking: Yes. If std.net.http is compiled as a static archive (.a), it is merely a bag of object files. It does not carry linkage information. The final executable linking against it must also link against libcurl.
Given Aria's preference for hermetic, static builds (as evidenced by the static integration of libcurl in the Gemini package 1), the ToolchainOrchestrator must implement Recursive Dependency Collection. When constructing the link command for a binary node, the orchestrator must traverse the graph of internal dependencies (depends_on), collecting libraries and library_paths from every upstream Node and aggregating them into the final command. This ensures that the user of std.net.http automatically inherits the necessary linker flags for libcurl without manual configuration, encapsulating the implementation details.
4. Implementation Strategy: The Toolchain Orchestrator
The implementation of ToolchainOrchestrator::construct_link_cmd in src/build/toolchain.cpp is the functional core of this specification. This method must translate the abstract data in the Node (and its transitive dependencies) into a concrete, OS-executable command string.
4.1 Platform Abstraction via Enums
The orchestrator utilizes a TargetPlatform enum (likely defined in toolchain.h) to branch its logic. This is populated at runtime or compile-time of the build tool.1


C++




enum class TargetPlatform {
   Linux,
   Windows,
   MacOS,
   Unknown
};

4.2 Algorithm for Command Construction
The command construction is not a simple append operation; it requires a multi-pass assembly process to satisfy the rigid ordering constraints of linkers.4
The Seven-Stage Assembly Process:
1. Linker Selection: Determine the binary to invoke (lld, gcc, cl.exe). On Linux, we often use the compiler driver (ariac or clang) to drive the linker, as this automatically handles C runtime (CRT) startup files (crt0.o) which are painful to configure manually.2
2. Output Specification: Append -o <file> or /OUT:<file>.
3. Library Path Injection: Append -L or /LIBPATH. These must typically precede the libraries they serve.
4. Transitive Path Injection: Append paths collected from dependencies.
5. Object File Injection: Append the .o / .obj files generated by the current build. Critical for Linux: These must appear before the libraries that resolve their symbols.3
6. Library Injection: Append -l or .lib entries.
   * Linux: Iterate libraries, prepend -l. Check for absolute paths (don't prepend -l if it looks like a file path).
   * Windows: Iterate libraries, append .lib if the extension is missing.
7. System Runtime Injection: Append standard system libraries (e.g., -lc, -lm, libucrt.lib) required by the Aria runtime itself.
4.3 Detailed C++ Implementation Logic
The following code block represents the comprehensive implementation logic for src/build/toolchain.cpp. It assumes the existence of helper functions for shell escaping and recursive graph traversal.


C++




/**
* @file src/build/toolchain.cpp
* @brief Implementation of the ToolchainOrchestrator, extended for FFI support.
*/

#include "build/toolchain.h"
#include <sstream>
#include <algorithm>

namespace aria {
namespace build {

// Helper to sanitize paths for shell execution (prevent injection)
std::string escape_shell_arg(const std::string& s) {
   // Implementation omitted: quotes string, escapes internal quotes
   return "\"" + s + "\""; 
}

std::pair<std::string, std::vector<std::string>> 
ToolchainOrchestrator::construct_link_cmd(
   const graph::Node* target_node, 
   const std::vector<std::string>& object_files) 
{
   std::vector<std::string> args;
   std::string linker_exe;

   // -------------------------------------------------------------------------
   // STRATEGY: Windows (PE/COFF) via LLD-LINK or MSVC LINK
   // -------------------------------------------------------------------------
   if (current_platform_ == TargetPlatform::Windows) {
       linker_exe = "lld-link"; // Prefer LLD for cross-platform consistency
       args.push_back(linker_exe);
       
       // 1. Prologue Flags
       args.push_back("/NOLOGO");
       args.push_back("/DEBUG"); // Always generate PDBs for diagnostics
       
       // Subsystem determination (Console vs Windows GUI)
       // Ideally configurable via Node flags, defaulting to CONSOLE
       args.push_back("/SUBSYSTEM:CONSOLE"); 
       
       // 2. Output File
       args.push_back("/OUT:" + target_node->output_file);
       
       // 3. Library Search Paths (/LIBPATH)
       // Windows linker searches these in order.
       
       // 3a. Node-specific paths
       for (const auto& path : target_node->library_paths) {
           args.push_back("/LIBPATH:" + escape_shell_arg(path));
       }
       
       // 3b. Transitive paths from dependencies (e.g., std.net -> libcurl path)
       auto transitive_paths = resolve_lib_paths(target_node); 
       for (const auto& path : transitive_paths) {
           args.push_back("/LIBPATH:" + escape_shell_arg(path));
       }

       // 4. Input Object Files (.obj)
       for (const auto& obj : object_files) {
           args.push_back(escape_shell_arg(obj));
       }

       // 5. Libraries (.lib)
       // Collect explicit and transitive libraries
       std::vector<std::string> all_libs = target_node->libraries;
       auto transitive_libs = resolve_libs(target_node);
       all_libs.insert(all_libs.end(), transitive_libs.begin(), transitive_libs.end());

       for (const auto& lib : all_libs) {
           // Windows linkers expect filenames. We must ensure the.lib extension exists.
           std::string lib_name = lib;
           // Simple heuristic: if no dot, append.lib
           if (lib_name.find('.') == std::string::npos) {
               lib_name += ".lib";
           }
           args.push_back(lib_name);
       }
       
       // 6. System Runtime Libraries (Critical for C++ Interop)
       // See  regarding CRT conflicts (/MD vs /MT). 
       // We link against the Universal CRT.
       args.push_back("libucrt.lib");
       args.push_back("libvcruntime.lib");
       args.push_back("libcmt.lib"); // Static CRT
   } 
   // -------------------------------------------------------------------------
   // STRATEGY: Linux (ELF) / macOS (Mach-O)
   // -------------------------------------------------------------------------
   else { 
       // Use the compiler driver to drive linking. This handles crt0.o setup.
       linker_exe = compiler_bin_; 
       args.push_back(linker_exe);
       
       // Force LLD if on Linux for performance and consistency
       if (current_platform_ == TargetPlatform::Linux) {
           args.push_back("-fuse-ld=lld"); 
       }
       
       // 2. Output File
       args.push_back("-o");
       args.push_back(target_node->output_file);
       
       // 3. Library Search Paths (-L)
       // Add paths from the current node
       for (const auto& path : target_node->library_paths) {
           args.push_back("-L" + escape_shell_arg(path));
       }
       
       // Add transitive paths
       auto transitive_paths = resolve_lib_paths(target_node);
       for (const auto& path : transitive_paths) {
           args.push_back("-L" + escape_shell_arg(path));
       }

       // 4. Input Object Files
       // CRITICAL ORDERING: Objects must come BEFORE libraries that resolve their symbols.
       for (const auto& obj : object_files) {
           args.push_back(escape_shell_arg(obj));
       }

       // 5. Libraries (-l)
       // Collect all libraries
       std::vector<std::string> all_libs = target_node->libraries;
       auto transitive_libs = resolve_libs(target_node);
       all_libs.insert(all_libs.end(), transitive_libs.begin(), transitive_libs.end());

       for (const auto& lib : all_libs) {
           // Check if it's a file path or a library name
           if (lib.find('/')!= std::string::npos |

| lib.find(".a")!= std::string::npos |
| lib.find(".so")!= std::string::npos) {
               // It's a path (e.g. /usr/lib/libfoo.a), pass directly
               args.push_back(escape_shell_arg(lib));
           } else {
               // It's a name (e.g. "curl"), prepend -l
               args.push_back("-l" + lib);
           }
       }
       
       // 6. System Runtime (often implicit with compiler driver, but explicit doesn't hurt)
       // args.push_back("-lc"); 
       // args.push_back("-lm"); 
       
       // RPATH handling for finding shared libs at runtime
       // args.push_back("-Wl,-rpath,$ORIGIN/../lib");
   }

   return {linker_exe, args};
}

} // namespace build
} // namespace aria

5. Advanced Linker Semantics and Optimization
Enhancing the orchestrator is not simply about making the build "work"; it is about making it performant and secure. Several advanced linker features must be considered in the architectural design.
5.1 RPATH/RUNPATH vs. LD_LIBRARY_PATH
On Linux, when linking against shared libraries located in non-standard directories (e.g., a vendor/libs folder distributed with the app), the resulting binary will not run unless the dynamic loader can find the .so files. Relying on users to set LD_LIBRARY_PATH is fragile and hostile to the developer experience.7
Architectural Decision: The ToolchainOrchestrator should automatically calculate relative paths between the output binary and any provided library_paths that are relative. It should then inject -Wl,-rpath,$ORIGIN/<relative_path> flags. This "bakes" the search path into the binary's ELF header, making the application portable and self-contained (relocatable).6
5.2 Static vs. Dynamic Linking Semantics
The distinction between static (.a, .lib) and dynamic (.so, .dll) linking profoundly affects flag generation.
* Static Linking (-static): If the user requests a fully static build, the orchestrator on Linux must pass -static. This changes the linker's behavior: it will search only for .a files and ignore .so files. This is vital for the hermetic build goals of Aria.1
* Symbol Grouping (--start-group): Circular dependencies between static libraries are a common issue. If LibA needs LibB, and LibB needs LibA, a single pass linker fails. The ToolchainOrchestrator can mitigate this by wrapping the library list in -Wl,--start-group... -Wl,--end-group on Linux/ELF systems. This forces the linker to cycle through the libraries until all symbols are resolved, at the cost of performance.
5.3 Debug Information and DWARF vs. PDB
Debugging FFI interactions requires symbol information. The implementation code explicitly adds /DEBUG for Windows 8 and relies on the compiler driver defaults for Linux (typically -g).
* Windows: The /DEBUG flag generates a .pdb (Program Database) file. The orchestrator must ensure this file is placed alongside the executable.
* Linux: Debug info is typically embedded in the ELF binary (DWARF sections). However, objcopy --only-keep-debug might be used in a post-link step to split debug info, a feature to consider for the "Release" build profile.
6. Security and Path Sanitization
The integration of external paths introduces "Dependency Confusion" and "DLL Hijacking" vectors.
6.1 Path Injection Vulnerabilities
If the library_paths vector contains strings derived from untrusted user input or environment variables, a malicious actor could inject linker flags. For example, a path like /usr/lib; rm -rf / would be catastrophic if passed to system().
* Mitigation: The implementation strictly uses llvm::sys::ExecuteAndWait (as detailed in 1), which invokes the process via execvp or CreateProcess directly, bypassing the shell. Furthermore, the escape_shell_arg function logic (though simplified in the snippet) must rigorously quote arguments to prevent argument splitting.
6.2 DLL Search Order Hijacking
On Windows, the /LIBPATH flag affects compile-time linking, but at runtime, the OS loader searches for DLLs in a specific order (Application Directory -> System Directory -> PATH). If the build system links against a DLL in a custom folder but fails to copy that DLL to the output directory, the application might load a malicious DLL of the same name from a system path.
* Mitigation: The build system's "Install" phase (separate from linking) must copy all referenced dynamic libraries to the output directory.
7. Integration Verification and Testing
To validate this architectural enhancement, a robust testing strategy is required.
7.1 Unit Testing the Command Construction
We can verify the logic of construct_link_cmd without invoking the actual linker by instantiating Node objects with known configurations and asserting the generated command vector.
Test Case: Linux FFI
* Configuration: TargetPlatform::Linux, libraries=["curl"], library_paths=["/opt/lib"].
* Input: Object file main.o.
* Assertion: The generated command must contain ... -L/opt/lib main.o -lcurl. Failure Condition: If -lcurl appears before main.o, the test fails (symbol resolution violation).
Test Case: Windows FFI
* Configuration: TargetPlatform::Windows, libraries=["curl"], library_paths=["C:/libs"].
* Assertion: The generated command must contain /LIBPATH:C:/libs... curl.lib. It must also contain the CRT libs libucrt.lib, etc.
7.2 Integration Test: The libcurl Scenario
The primary driver for this feature is the std.net.http module.1 The integration test involves:
1. CMake Build: Using FetchContent to build libcurl statically, producing libcurl.a (Linux) or curl.lib (Windows).
2. Aria Config: Creating a build.aria file pointing to the CMake output directory via library_paths.
3. Execution: Running aria_make.
4. Verification: The resulting binary acts as an HTTP client. It should successfully initialize a CURL handle. If linking fails (e.g., missing OpenSSL symbols transitively required by CURL), the linker output captured in ExecResult.err_output should clearly indicate "undefined reference."
8. Conclusion
The architectural enhancement of the Node structure and ToolchainOrchestrator to support FFI linking transforms AriaBuild from a simple compiler driver into a production-grade build system. By rigorously addressing the platform-specific divergences of ELF and COFF linking, implementing transitive dependency resolution, and adhering to strict ordering semantics, this design enables the seamless integration of the Aria language with the global ecosystem of C/C++ software. This capability is the keystone for the "Gemini Work Package," allowing Aria to fulfill its promise as a high-performance systems language capable of operating in complex, real-world environments.
9. Appendix: Linker Flag Reference Table
The following table summarizes the mapping logic implemented in the Orchestrator to ensure cross-platform compatibility.
Feature
	Linux/macOS Flag (GNU/LLVM)
	Windows Flag (MSVC/LLD-LINK)
	Implementation Logic
	Output File
	-o <file>
	/OUT:<file>
	Mapped from Node::output_file
	Lib Search Path
	-L<path>
	/LIBPATH:<path>
	Iterated from Node::library_paths
	Link Library
	-l<name>
	<name>.lib
	Iterated from Node::libraries
	Input Object
	<file>.o
	<file>.obj
	Passed from build phase
	Debug Info
	-g (Compiler)
	/DEBUG
	Hardcoded default for safety
	Static Link
	-static
	N/A (Link distinct .lib)
	Configurable via build profile
	RPATH
	-Wl,-rpath,<path>
	N/A (Delay load / Copy)
	Calculated relative path
	This specification provides the complete roadmap for the implementation team to execute Task 7 and close the critical gap in the Aria toolchain.
Works cited
1. compiled.txt
2. How can I find out what linker flags are needed to use a given C library function?, accessed December 20, 2025, https://unix.stackexchange.com/questions/277845/how-can-i-find-out-what-linker-flags-are-needed-to-use-a-given-c-library-functio
3. Link Options (Using the GNU Compiler Collection (GCC)), accessed December 20, 2025, https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html
4. Why does the order in which libraries are linked sometimes cause errors in GCC?, accessed December 20, 2025, https://stackoverflow.com/questions/45135/why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc
5. /LIBPATH (Additional Libpath) | Microsoft Learn, accessed December 20, 2025, https://learn.microsoft.com/en-us/cpp/build/reference/libpath-additional-libpath?view=msvc-170
6. How to specify preference of library path? - Stack Overflow, accessed December 20, 2025, https://stackoverflow.com/questions/2726993/how-to-specify-preference-of-library-path
7. What is the difference between LD_LIBRARY_PATH and -L at link time? - Stack Overflow, accessed December 20, 2025, https://stackoverflow.com/questions/1904990/what-is-the-difference-between-ld-library-path-and-l-at-link-time
8. What are the useful GCC flags for C? - Stack Overflow, accessed December 20, 2025, https://stackoverflow.com/questions/3375697/what-are-the-useful-gcc-flags-for-c